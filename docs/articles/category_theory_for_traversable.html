<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="format-detection" content="telephone=no" />

    <title>Traversable のための圏論 - Hexirp's Blog</title>

    <meta name="keywords" content="" />
    <meta name="description" content="Haskell の Traversable を圏論で形式化する二通りの方法について。" />
    <meta name="author" content="Hexirp" />

    <link rel="canonical" href="https://hexirp.github.io/blog/articles/category_theory_for_traversable.html" />

    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="Hexirp's Blog" />
    <meta property="og:title" content="Traversable のための圏論 - Hexirp's Blog" />
    <meta property="og:description" content="Haskell の Traversable を圏論で形式化する二通りの方法について。" />
    <meta property="og:image" content="https://hexirp.github.io/blog/icon.png" />
    <meta property="og:url" content="https://hexirp.github.io/blog/articles/category_theory_for_traversable.html" />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@hexirp_prixeh" />
    <meta name="twitter:title" content="Traversable のための圏論 - Hexirp's Blog" />
    <meta name="twitter:description" content="Haskell の Traversable を圏論で形式化する二通りの方法について。" />
    <meta name="twitter:image" content="https://hexirp.github.io/blog/icon.png" />

    <link rel="icon" href="/blog/small_icon.png" />

    <link rel="apple-touch-icon" href="/blog/icon.png" />

    <link rel="stylesheet" href="/blog/styles/main.css" />
  </head>

  <body>
    <header>
      <div id="icon">
        <img src="/blog/icon.png" alt="Hexirp's icon" width="64" height="64" />
      </div>

      <ul id="nav">
        <li><a href="/blog/">Home</a></li>
        <li><a href="https://twitter.com/hexirp_prixeh">Twitter</a></li>
        <li><a href="https://github.com/Hexirp">GitHub</a></li>
      </ul>
    </header>

    <main>
<h1 id="traversable-のための圏論">Traversable のための圏論</h1>
<p>Haskell の <code>Traversable</code> 型クラスは、私が好きな型クラスの一つです。 <code>Foldable</code> 型クラスには <code>Foldable</code> 則がないという問題があります（私は <a href="http://eed3si9n.com/learning-scalaz/ja/Lawless-typeclasses.html">独習 Scalaz</a> で知りました）。すなわち無法者 (lawless) だというのです。 しかし <code>Traversable</code> はどうでしょうか？ <code>Foldable</code> と根を同じくしながらも <code>Traversable</code> 則を持っています。このことに私はいたく感動しました。ですから、 私は <code>Traversable</code> 型クラスが好きです。</p>
<p>話を変えましょう。Haskell は圏論と関係深い言語です。代表的なのは <code>Functor</code> や <code>Monad</code> という概念でしょう。断らないといけないのは、Haskell と圏論の関係に ついては様々な考え方があり、誤った考え方を修正しようとする人が多いことです。 それは良いことだとも言えますが、もしあなたがこれについて間違ったことをどこかに 書いてしまったら、あなたが間違ったことを書いてしまったことが、他の人たちへ 一瞬で広まっていきます。自分が間違ってしまったという事を広められたくない人は 注意するべきです。</p>
<p>話を戻すと、最初に出した例は型クラスでしたね。<code>Closed</code> など、<code>Functor</code> 型クラスに圏論に由来する何らかの条件を付けた型クラスが多くあります。また、 <code>Contravariant</code> は圏論の「反変関手」という概念を型クラスで表現したものです。 さらに <code>Profunctor</code> や <code>Bifunctor</code> など派生した型クラスが大量にあります。 圏論は「圏」についての分野ですが、そのものずばり <code>Category</code> という型クラスも あります。さらに、それの <code>Arrow</code> という派生は <code>Monad</code> に代わるもう一つの プログラミングの抽象化として知っておくべきです。</p>
<p>「Traversable」と「圏論」という二つの話が出ました。この記事は、この二つの 結び付きを解説するものです。</p>
<h2 id="traversable-の定義">Traversable の定義</h2>
<p>定義をおさらいしましょう。ソースコードから抜き出したのが下のです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="co">-- | Functors representing data structures that can be traversed from</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">-- left to right.</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">-- A definition of &#39;traverse&#39; must satisfy the following laws:</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">-- [/naturality/]</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">--   @t . &#39;traverse&#39; f = &#39;traverse&#39; (t . f)@</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co">--   for every applicative transformation @t@</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">-- [/identity/]</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">--   @&#39;traverse&#39; Identity = Identity@</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">-- [/composition/]</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">--   @&#39;traverse&#39; (Compose . &#39;fmap&#39; g . f) = Compose . &#39;fmap&#39; (&#39;traverse&#39; g) . &#39;traverse&#39; f@</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co">-- A definition of &#39;sequenceA&#39; must satisfy the following laws:</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co">-- [/naturality/]</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">--   @t . &#39;sequenceA&#39; = &#39;sequenceA&#39; . &#39;fmap&#39; t@</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">--   for every applicative transformation @t@</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="co">-- [/identity/]</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">--   @&#39;sequenceA&#39; . &#39;fmap&#39; Identity = Identity@</span></a>
<a class="sourceLine" id="cb1-24" title="24"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-25" title="25"><span class="co">-- [/composition/]</span></a>
<a class="sourceLine" id="cb1-26" title="26"><span class="co">--   @&#39;sequenceA&#39; . &#39;fmap&#39; Compose = Compose . &#39;fmap&#39; &#39;sequenceA&#39; . &#39;sequenceA&#39;@</span></a>
<a class="sourceLine" id="cb1-27" title="27"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-28" title="28"><span class="co">-- where an /applicative transformation/ is a function</span></a>
<a class="sourceLine" id="cb1-29" title="29"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-30" title="30"><span class="co">-- @t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a@</span></a>
<a class="sourceLine" id="cb1-31" title="31"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-32" title="32"><span class="co">-- preserving the &#39;Applicative&#39; operations, i.e.</span></a>
<a class="sourceLine" id="cb1-33" title="33"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="co">--  * @t (&#39;pure&#39; x) = &#39;pure&#39; x@</span></a>
<a class="sourceLine" id="cb1-35" title="35"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-36" title="36"><span class="co">--  * @t (x &#39;&lt;*&gt;&#39; y) = t x &#39;&lt;*&gt;&#39; t y@</span></a>
<a class="sourceLine" id="cb1-37" title="37"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-38" title="38"><span class="co">-- and the identity functor @Identity@ and composition of functors @Compose@</span></a>
<a class="sourceLine" id="cb1-39" title="39"><span class="co">-- are defined as</span></a>
<a class="sourceLine" id="cb1-40" title="40"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-41" title="41"><span class="co">-- &gt;   newtype Identity a = Identity a</span></a>
<a class="sourceLine" id="cb1-42" title="42"><span class="co">-- &gt;</span></a>
<a class="sourceLine" id="cb1-43" title="43"><span class="co">-- &gt;   instance Functor Identity where</span></a>
<a class="sourceLine" id="cb1-44" title="44"><span class="co">-- &gt;     fmap f (Identity x) = Identity (f x)</span></a>
<a class="sourceLine" id="cb1-45" title="45"><span class="co">-- &gt;</span></a>
<a class="sourceLine" id="cb1-46" title="46"><span class="co">-- &gt;   instance Applicative Identity where</span></a>
<a class="sourceLine" id="cb1-47" title="47"><span class="co">-- &gt;     pure x = Identity x</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="co">-- &gt;     Identity f &lt;*&gt; Identity x = Identity (f x)</span></a>
<a class="sourceLine" id="cb1-49" title="49"><span class="co">-- &gt;</span></a>
<a class="sourceLine" id="cb1-50" title="50"><span class="co">-- &gt;   newtype Compose f g a = Compose (f (g a))</span></a>
<a class="sourceLine" id="cb1-51" title="51"><span class="co">-- &gt;</span></a>
<a class="sourceLine" id="cb1-52" title="52"><span class="co">-- &gt;   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where</span></a>
<a class="sourceLine" id="cb1-53" title="53"><span class="co">-- &gt;     fmap f (Compose x) = Compose (fmap (fmap f) x)</span></a>
<a class="sourceLine" id="cb1-54" title="54"><span class="co">-- &gt;</span></a>
<a class="sourceLine" id="cb1-55" title="55"><span class="co">-- &gt;   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where</span></a>
<a class="sourceLine" id="cb1-56" title="56"><span class="co">-- &gt;     pure x = Compose (pure (pure x))</span></a>
<a class="sourceLine" id="cb1-57" title="57"><span class="co">-- &gt;     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)</span></a>
<a class="sourceLine" id="cb1-58" title="58"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-59" title="59"><span class="co">-- (The naturality law is implied by parametricity.)</span></a>
<a class="sourceLine" id="cb1-60" title="60"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-61" title="61"><span class="co">-- Instances are similar to &#39;Functor&#39;, e.g. given a data type</span></a>
<a class="sourceLine" id="cb1-62" title="62"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-63" title="63"><span class="co">-- &gt; data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)</span></a>
<a class="sourceLine" id="cb1-64" title="64"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-65" title="65"><span class="co">-- a suitable instance would be</span></a>
<a class="sourceLine" id="cb1-66" title="66"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-67" title="67"><span class="co">-- &gt; instance Traversable Tree where</span></a>
<a class="sourceLine" id="cb1-68" title="68"><span class="co">-- &gt;    traverse f Empty = pure Empty</span></a>
<a class="sourceLine" id="cb1-69" title="69"><span class="co">-- &gt;    traverse f (Leaf x) = Leaf &lt;$&gt; f x</span></a>
<a class="sourceLine" id="cb1-70" title="70"><span class="co">-- &gt;    traverse f (Node l k r) = Node &lt;$&gt; traverse f l &lt;*&gt; f k &lt;*&gt; traverse f r</span></a>
<a class="sourceLine" id="cb1-71" title="71"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-72" title="72"><span class="co">-- This is suitable even for abstract types, as the laws for &#39;&lt;*&gt;&#39;</span></a>
<a class="sourceLine" id="cb1-73" title="73"><span class="co">-- imply a form of associativity.</span></a>
<a class="sourceLine" id="cb1-74" title="74"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-75" title="75"><span class="co">-- The superclass instances should satisfy the following:</span></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-77" title="77"><span class="co">--  * In the &#39;Functor&#39; instance, &#39;fmap&#39; should be equivalent to traversal</span></a>
<a class="sourceLine" id="cb1-78" title="78"><span class="co">--    with the identity applicative functor (&#39;fmapDefault&#39;).</span></a>
<a class="sourceLine" id="cb1-79" title="79"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-80" title="80"><span class="co">--  * In the &#39;Foldable&#39; instance, &#39;Data.Foldable.foldMap&#39; should be</span></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="co">--    equivalent to traversal with a constant applicative functor</span></a>
<a class="sourceLine" id="cb1-82" title="82"><span class="co">--    (&#39;foldMapDefault&#39;).</span></a>
<a class="sourceLine" id="cb1-83" title="83"><span class="co">--</span></a>
<a class="sourceLine" id="cb1-84" title="84"><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-85" title="85">    <span class="ot">{-# MINIMAL traverse | sequenceA #-}</span></a>
<a class="sourceLine" id="cb1-86" title="86"></a>
<a class="sourceLine" id="cb1-87" title="87">    <span class="co">-- | Map each element of a structure to an action, evaluate these actions</span></a>
<a class="sourceLine" id="cb1-88" title="88">    <span class="co">-- from left to right, and collect the results. For a version that ignores</span></a>
<a class="sourceLine" id="cb1-89" title="89">    <span class="co">-- the results see &#39;Data.Foldable.traverse_&#39;.</span></a>
<a class="sourceLine" id="cb1-90" title="90"><span class="ot">    traverse ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</a>
<a class="sourceLine" id="cb1-91" title="91">    <span class="ot">{-# INLINE traverse #-}</span>  <span class="co">-- See Note [Inline default methods]</span></a>
<a class="sourceLine" id="cb1-92" title="92">    <span class="fu">traverse</span> f <span class="fu">=</span> <span class="fu">sequenceA</span> <span class="fu">.</span> <span class="fu">fmap</span> f</a>
<a class="sourceLine" id="cb1-93" title="93"></a>
<a class="sourceLine" id="cb1-94" title="94">    <span class="co">-- | Evaluate each action in the structure from left to right, and</span></a>
<a class="sourceLine" id="cb1-95" title="95">    <span class="co">-- collect the results. For a version that ignores the results</span></a>
<a class="sourceLine" id="cb1-96" title="96">    <span class="co">-- see &#39;Data.Foldable.sequenceA_&#39;.</span></a>
<a class="sourceLine" id="cb1-97" title="97"><span class="ot">    sequenceA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f (t a)</a>
<a class="sourceLine" id="cb1-98" title="98">    <span class="ot">{-# INLINE sequenceA #-}</span>  <span class="co">-- See Note [Inline default methods]</span></a>
<a class="sourceLine" id="cb1-99" title="99">    <span class="fu">sequenceA</span> <span class="fu">=</span> <span class="fu">traverse</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb1-100" title="100"></a>
<a class="sourceLine" id="cb1-101" title="101">    <span class="co">-- | Map each element of a structure to a monadic action, evaluate</span></a>
<a class="sourceLine" id="cb1-102" title="102">    <span class="co">-- these actions from left to right, and collect the results. For</span></a>
<a class="sourceLine" id="cb1-103" title="103">    <span class="co">-- a version that ignores the results see &#39;Data.Foldable.mapM_&#39;.</span></a>
<a class="sourceLine" id="cb1-104" title="104"><span class="ot">    mapM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</a>
<a class="sourceLine" id="cb1-105" title="105">    <span class="ot">{-# INLINE mapM #-}</span>  <span class="co">-- See Note [Inline default methods]</span></a>
<a class="sourceLine" id="cb1-106" title="106">    <span class="fu">mapM</span> <span class="fu">=</span> <span class="fu">traverse</span></a>
<a class="sourceLine" id="cb1-107" title="107"></a>
<a class="sourceLine" id="cb1-108" title="108">    <span class="co">-- | Evaluate each monadic action in the structure from left to</span></a>
<a class="sourceLine" id="cb1-109" title="109">    <span class="co">-- right, and collect the results. For a version that ignores the</span></a>
<a class="sourceLine" id="cb1-110" title="110">    <span class="co">-- results see &#39;Data.Foldable.sequence_&#39;.</span></a>
<a class="sourceLine" id="cb1-111" title="111"><span class="ot">    sequence ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m (t a)</a>
<a class="sourceLine" id="cb1-112" title="112">    <span class="ot">{-# INLINE sequence #-}</span>  <span class="co">-- See Note [Inline default methods]</span></a>
<a class="sourceLine" id="cb1-113" title="113">    <span class="fu">sequence</span> <span class="fu">=</span> <span class="fu">sequenceA</span></a></code></pre></div>
<p>必要な関数は <code>traversal</code> または <code>sequenceA</code> で、どっちにもいくつかの条件が 必要になるという一般的な型クラスですね。条件を読み解くと <code>Functor</code> とは違い 条件を記述するために新しい定義をしています——Applicative transformer と Identity と Compose です。Traversable を圏論で表現するときは、これらの 概念が重要になってきます。</p>
<h2 id="applicative-と圏論">Applicative と圏論</h2>
<p><code>Applicative</code> 型クラスは、圏論のモノイダル関手 (monoidal functor) と結び付け られます。圏論のモノイダル関手は C というモノイダル圏から D というモノイダル 圏への自然な条件を満たす関手ですが、Haskell の <code>Applicative</code> は特殊化されて いて、Hask という Haskell の型を対象として、型の間の関数を射とする圏を、 <code>(,)</code> と <code>()</code> によってモノイダル圏にしたもの、それからそれへのモノイダル 関手です。</p>
<p>さて、二つの関手の間には自然変換が考えられます。同じように二つのモノイダル 関手の間にある自然変換のようなものが考えられます。二つの圏の間の関手が、 二つのモノイダル圏の間のモノイダル関手と発展したように、その何かは自然変換を 発展させたものであることが予測されます。つまり、自然変換に何かモノイダル関手の 構造と合うような条件を付けたものになると考えられます。</p>
<p>実際にその通りになり、上のソースコードから抜き出すと、下のように定義されて います。さっきまでの話は難しかったかと思いますが、Haskell のソースコードで 表現するとこういう風になるものなんだと分かっていれば大丈夫です。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="co">-- ~~~</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">-- where an /applicative transformation/ is a function</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">-- @t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a@</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">-- preserving the &#39;Applicative&#39; operations, i.e.</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co">--  * @t (&#39;pure&#39; x) = &#39;pure&#39; x@</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">--  * @t (x &#39;&lt;*&gt;&#39; y) = t x &#39;&lt;*&gt;&#39; t y@</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">-- ~~~</span></a></code></pre></div>
<p>ちなみに <code>Functor f</code> と <code>Functor g</code> の間の自然変換は <code>t :: f a -&gt; g a</code> と いう型を持ちますが、このような型を持つ関数は、驚くべきことに必ず自然変換に なります。モノイダル関手ではそういうことはありません（リストから <code>ZipList</code> への関数が反例になります）。</p>
<hr />
<p>関手には、恒等関手があり関手の合成があります。ゆえに圏になります。それが圏と 関手の圏と呼ばれるものです。Haskell では恒等関手と関手の合成はこのように 書かれます。つまり <code>Identity</code> が恒等関手であり二つの関手 <code>f</code> と <code>g</code> を 合成した関手が <code>Compose f g</code> です。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">newtype</span> <span class="dt">Compose</span> f g a <span class="fu">=</span> <span class="dt">Compose</span> (f (g a))</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="fu">fmap</span> f (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a)</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="fu">fmap</span> f (<span class="dt">Compose</span> a) <span class="fu">=</span> <span class="dt">Compose</span> (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) a)</a></code></pre></div>
<p>モノイダル関手には、恒等モノイダル関手がありモノイダル関手の合成があります。 より分かりやすくいうと、恒等関手はモノイダルであり、二つのモノイダル関手の 合成はモノイダル関手になります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Identity</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="fu">pure</span> x <span class="fu">=</span> <span class="dt">Identity</span> x</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">Identity</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Identity</span> x <span class="fu">=</span> <span class="dt">Identity</span> (f x)</a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Applicative</span> g) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Compose</span> f g) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="fu">pure</span> x <span class="fu">=</span> <span class="dt">Compose</span> (<span class="fu">pure</span> (<span class="fu">pure</span> x))</a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">Compose</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Compose</span> x <span class="fu">=</span> <span class="dt">Compose</span> ((<span class="fu">&lt;*&gt;</span>) <span class="fu">&lt;$&gt;</span> f <span class="fu">&lt;*&gt;</span> x)</a></code></pre></div>
<p>ちなみに、モナドには合成がありません。モナド変換子は、もし合成があったのならば 必要なかったでしょう。この話は本題と逸れますが、面白いので調べてみてください。</p>
<p>さて、ここまで applicative transformer と Identity と Compose の圏論の 結びつきを解説してきました。Traversable を圏論で考えるときに、これらの定義が 効いてくるのです。</p>
<h2 id="特殊な自然変換を持った関手">特殊な自然変換を持った関手</h2>
<p><code>Traversable</code> は <code>Functor</code> のうち特殊な条件を満たすものでしたから、 圏論でも特殊な関手として表現できるでしょう。では、どのように特殊なのでしょう か。</p>
<p>核になるのは <code>sequenceA</code> です。つまり、<code>sequenceA</code> が任意の applicative な関手に対しての自然変換として見れることを使います。</p>
<dl>
<dt>関手 T が、traversable であるとは、</dt>
<dd><p>任意の applicative な関手 F に対して d という TF から FT の自然変換が存在し、 ほにゃららという条件を満たすことである。</p>
</dd>
</dl>
<p>この「ほにゃらら」は、上の Traversable のソースコードにある Traversable 則を 圏論的に書き表したものです。Traversable 則は以下の通りです。ただし <code>d</code> で <code>sequenceA</code> を置き換えました。</p>
<dl>
<dt>naturality</dt>
<dd><p><code>t . d = d . fmap t</code> for every applicative transformation <code>t</code></p>
</dd>
<dt>identity</dt>
<dd><p><code>d . fmap Identity = Identity</code></p>
</dd>
<dt>composition</dt>
<dd><p><code>d . fmap Compose = Compose . fmap d . d</code></p>
</dd>
</dl>
<p>まず、これは何と何が等しいと言っているのでしょうか？ 関数と関数が等しいことを 表すと考えてもいいかもしれませんが、両辺とも自然変換になっています（applicative transfomation ではありません）。さらに言えば関手と自然変換の圏の上で考えた方が いいでしょう。可換図式が書けます！</p>
<p>参考にした論文では “A traversable functor is a functor ‘T : C -&gt; C’ equipped with a distributive law ‘d_F : TF -&gt; FT’ for T over the action of App on C by evaluation.” と書かれていて action という言葉を使って定義されているのですが、 よく分からなかったので直後に書いてある明示的な則を載せました。</p>
<p>可換図式は下のようになります。ただし、<code>d_F</code> は F に対する d を表します （任意の applicative な関手に対する自然変換だったのでした）。</p>
<pre class="sourceCode text"><code>naturality:

          d_F
    TF ---------&gt; FT

    |             |
    |             |
 Ta |             | aT
    |             |
    v             v

    TG ---------&gt; GT
          d_G

           for every morphism &#39;a&#39; in &#39;App&#39;

composition:

             d_(FG)
  TFG -------------------&gt; FGT

  |                        ^
  |                        |
  +---------&gt; FTG ---------+
    (d_F)G         F(d_G)

identity:

      d_I
 TI ---------+
             |
 |           v
 |
 +---------&gt; IT
      id</code></pre>
<p>追記 (2019/01/26): action は、圏論的な意味を持たない、「なんかに働くよー」って いう意味で使われているというだけの単語みたいです。これを踏まえて訳してみると、 「evaluation による圏 C (よくわからないけど Hask みたいなもの？) の上での App (applicative functor と applicative transformer の圏) の対象について渡る 分配則 ‘d_F : TF -&gt; FT’ で特徴づけられる関手 ‘T : C -&gt; C’ が traversable functor である」って感じでしょうか？</p>
<h2 id="ある圏の自己関手">ある圏の自己関手</h2>
<p><a href="#特殊な自然変換を持った関手">特殊な自然変換を持った関手</a> 節では <code>sequenceA</code> を使って形式化しました。 では、<code>traverse</code> を使った形式化もあるのでしょうか？ あります。</p>
<p>とある圏を考えましょう。対象は Haskell の型です。<code>A</code> から <code>B</code> への射は 任意の <code>Applicative</code> である <code>F</code> に対して <code>A -&gt; F B</code> です。スライス圏と 同じような感じだと思ってください。この定義はちょっと非直感的なので Haskell で 書き下しましょう。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="co">-- 対象は A :: * である。</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">-- 対象 A, B に対して、任意の F において Applicative F であるならば</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">-- f : A -&gt; F B は射である。</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="kw">data</span> <span class="dt">C</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-6" title="6"> <span class="dt">Mk_C</span><span class="ot"> ::</span> <span class="kw">forall</span> f<span class="fu">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">C</span> a b</a></code></pre></div>
<p>恒等射と合成はこのように実装されます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">id</span><span class="ot"> ::</span> <span class="dt">C</span> a a</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">id</span> <span class="fu">=</span> <span class="dt">Mk_C</span> (<span class="fu">pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> a)</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4">(<span class="fu">.</span>)</a>
<a class="sourceLine" id="cb7-5" title="5"><span class="ot">  ::</span> <span class="dt">C</span> b c</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="ot">-&gt;</span> <span class="dt">C</span> a b</a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="ot">-&gt;</span> <span class="dt">C</span> a c</a>
<a class="sourceLine" id="cb7-8" title="8">(<span class="dt">Mk_C</span> g) <span class="fu">.</span> (<span class="dt">Mk_C</span> f) <span class="fu">=</span> <span class="dt">C</span> (<span class="dt">Compose</span> <span class="fu">.</span> <span class="fu">fmap</span> g <span class="fu">.</span> f)</a></code></pre></div>
<p><code>Traversable</code> は、この圏の特殊な自己関手です。つまり、この関手は、このような 型クラスとして説明されます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span> <span class="dt">Traversable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">  tmap ::</span> <span class="dt">C</span> a b <span class="ot">-&gt;</span> <span class="dt">C</span> (t a) (t b)</a></code></pre></div>
<p>そして、引数が含む存在量化された型 <code>f</code> が、返り値が含む存在量化された 型 <code>g</code> と一致する条件が課されます。もちろん関手であるための条件もです。</p>
<p>これでうまくいくことの説明は読者への演習問題とします（めんどくさいだけ）。</p>
<h2 id="終わりに">終わりに</h2>
<p>Traversable の圏論での形式化を二通り紹介しました。どっちにしても、楽しいです よね！</p>
<p>ちなみに「ある圏の自己関手」での定義方法は自分の思いつきです。誰かが先に考えて いると思いますが（と予防線を張る）。</p>
<p>追記 (2019/01/24): 先に考えている人がいました (<a href="https://duplode.github.io/posts/traversable-a-remix.html" class="uri">https://duplode.github.io/posts/traversable-a-remix.html</a>) 。</p>
<h2 id="出典">出典</h2>
<ul>
<li>Traversable の定義 - <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html" class="uri">https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html</a></li>
<li>特殊な自然変換を持った関手 - <a href="https://arxiv.org/abs/1809.00738">Categories of Optics</a> の Definition 4.6.2</li>
</ul>
    </main>
  </body>
</html>
