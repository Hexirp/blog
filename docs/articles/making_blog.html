<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="author" content="Hexirp" />
    <meta name=”robots” content=”noindex”>

    <link rel="icon" href="/icon.png" />

    <title>このブログの制作記録 - Hexirp's Blog</title>

    <link rel="stylesheet" href="/styles/main.css" />
  </head>

  <body>
    <header>
      <div id="icon">
        <a href="/">
          <img src="/icon.png" alt="Hexirp's icon" width="64" height="64" />
        </a>
      </div>

      <ul id="nav">
        <li><a href="/about.html">About</a></li>
        <li><a href="https://twitter.com/hexirp_prixeh">Twitter</a></li>
        <li><a href="https://github.com/Hexirp">GitHub</a></li>
      </ul>
    </header>

    <main>
      <h1 id="このブログの制作記録">このブログの制作記録</h1>
<p>このブログを作った記録です。</p>
<h2 id="hakyll">Hakyll</h2>
<p>私は記事が一つ出来たらGitHub Pagesで公開しようと考えていました。</p>
<p>ついさっき、記事が一つ完成したので作業を始めました。 Haskellで書かれた静的なウェブサイトのためのコンパイラ、 <a href="#hakyll">hakyll</a>が色々なところで使われていて定番といえるため。それを使います。</p>
<p>まず、依存関係に加えたのですがビルドに約1時間かかってしまった上に、 最終的にWindowsで発生するGHCそのもののバグで失敗してしまいました。</p>
<pre class="sourceCode text"><code>Configuring hakyll-4.12.3.0...
Preprocessing library for hakyll-4.12.3.0..
Building library for hakyll-4.12.3.0..
[ 1 of 53] Compiling Data.List.Extended ( lib\Data\List\Extended.hs, .stack-work\dist\5c8418a7\build\Data\List\Extended.o )
[ 2 of 53] Compiling Data.Yaml.Extended ( lib\Data\Yaml\Extended.hs, .stack-work\dist\5c8418a7\build\Data\Yaml\Extended.o )
[ 3 of 53] Compiling Hakyll.Core.Configuration ( lib\Hakyll\Core\Configuration.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Configuration.o )
[ 4 of 53] Compiling Hakyll.Core.Identifier ( lib\Hakyll\Core\Identifier.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Identifier.o )
[ 5 of 53] Compiling Hakyll.Core.Identifier.Pattern.Internal ( lib\Hakyll\Core\Identifier\Pattern\Internal.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Identifier\Pattern\Internal.o )
[ 6 of 53] Compiling Hakyll.Core.Identifier.Pattern ( lib\Hakyll\Core\Identifier\Pattern.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Identifier\Pattern.o )
[ 7 of 53] Compiling Hakyll.Core.Dependencies ( lib\Hakyll\Core\Dependencies.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Dependencies.o )
[ 8 of 53] Compiling Hakyll.Core.Logger ( lib\Hakyll\Core\Logger.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Logger.o )
[ 9 of 53] Compiling Hakyll.Core.Metadata ( lib\Hakyll\Core\Metadata.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Metadata.o )
[10 of 53] Compiling Hakyll.Core.Store ( lib\Hakyll\Core\Store.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Store.o )
[11 of 53] Compiling Hakyll.Core.Util.File ( lib\Hakyll\Core\Util\File.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Util\File.o )
[12 of 53] Compiling Hakyll.Core.Provider.Internal ( lib\Hakyll\Core\Provider\Internal.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Provider\Internal.o )
[13 of 53] Compiling Hakyll.Core.Provider.Metadata ( lib\Hakyll\Core\Provider\Metadata.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Provider\Metadata.o )
[14 of 53] Compiling Hakyll.Core.Provider.MetadataCache ( lib\Hakyll\Core\Provider\MetadataCache.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Provider\MetadataCache.o )
[15 of 53] Compiling Hakyll.Core.Provider ( lib\Hakyll\Core\Provider.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Provider.o )
[16 of 53] Compiling Hakyll.Core.Util.Parser ( lib\Hakyll\Core\Util\Parser.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Util\Parser.o )
[17 of 53] Compiling Hakyll.Core.Util.String ( lib\Hakyll\Core\Util\String.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Util\String.o )
[18 of 53] Compiling Hakyll.Core.Routes ( lib\Hakyll\Core\Routes.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Routes.o )
[19 of 53] Compiling Hakyll.Core.Compiler.Internal ( lib\Hakyll\Core\Compiler\Internal.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Compiler\Internal.o )
[20 of 53] Compiling Hakyll.Core.Item ( lib\Hakyll\Core\Item.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Item.o )
[21 of 53] Compiling Hakyll.Core.Compiler.Require ( lib\Hakyll\Core\Compiler\Require.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Compiler\Require.o )
[22 of 53] Compiling Hakyll.Core.Compiler ( lib\Hakyll\Core\Compiler.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Compiler.o )
[23 of 53] Compiling Hakyll.Core.UnixFilter ( lib\Hakyll\Core\UnixFilter.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\UnixFilter.o )
[24 of 53] Compiling Hakyll.Core.Writable ( lib\Hakyll\Core\Writable.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Writable.o )
[25 of 53] Compiling Hakyll.Core.Item.SomeItem ( lib\Hakyll\Core\Item\SomeItem.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Item\SomeItem.o )
[26 of 53] Compiling Hakyll.Core.Rules.Internal ( lib\Hakyll\Core\Rules\Internal.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Rules\Internal.o )
[27 of 53] Compiling Hakyll.Core.Runtime ( lib\Hakyll\Core\Runtime.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Runtime.o )
[28 of 53] Compiling Hakyll.Core.Rules ( lib\Hakyll\Core\Rules.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\Rules.o )
[29 of 53] Compiling Hakyll.Core.File ( lib\Hakyll\Core\File.hs, .stack-work\dist\5c8418a7\build\Hakyll\Core\File.o )
[30 of 53] Compiling Hakyll.Preview.Poll ( lib\Hakyll\Preview\Poll.hs, .stack-work\dist\5c8418a7\build\Hakyll\Preview\Poll.o )

lib\Hakyll\Preview\Poll.hs:21:1: warning: [-Wunused-imports]
    The import of ‘throw’ from module ‘Control.Exception’ is redundant
   |
21 | import           Control.Exception              (IOException, throw, try)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[31 of 53] Compiling Hakyll.Preview.Server ( lib\Hakyll\Preview\Server.hs, .stack-work\dist\5c8418a7\build\Hakyll\Preview\Server.o )
[32 of 53] Compiling Hakyll.Web.CompressCss ( lib\Hakyll\Web\CompressCss.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\CompressCss.o )
[33 of 53] Compiling Hakyll.Web.Html  ( lib\Hakyll\Web\Html.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Html.o )
[34 of 53] Compiling Hakyll.Web.Html.RelativizeUrls ( lib\Hakyll\Web\Html\RelativizeUrls.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Html\RelativizeUrls.o )
[35 of 53] Compiling Hakyll.Web.Pandoc.Binary ( lib\Hakyll\Web\Pandoc\Binary.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Pandoc\Binary.o )
[36 of 53] Compiling Hakyll.Web.Pandoc.FileType ( lib\Hakyll\Web\Pandoc\FileType.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Pandoc\FileType.o )
[37 of 53] Compiling Hakyll.Web.Pandoc ( lib\Hakyll\Web\Pandoc.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Pandoc.o )
[38 of 53] Compiling Hakyll.Web.Pandoc.Biblio ( lib\Hakyll\Web\Pandoc\Biblio.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Pandoc\Biblio.o )
[39 of 53] Compiling Hakyll.Web.Redirect ( lib\Hakyll\Web\Redirect.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Redirect.o )
[40 of 53] Compiling Hakyll.Web.Template.Context ( lib\Hakyll\Web\Template\Context.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Template\Context.o )
[41 of 53] Compiling Hakyll.Web.Tags  ( lib\Hakyll\Web\Tags.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Tags.o )
[42 of 53] Compiling Hakyll.Web.Paginate ( lib\Hakyll\Web\Paginate.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Paginate.o )
[43 of 53] Compiling Hakyll.Web.Template.Internal.Element ( lib\Hakyll\Web\Template\Internal\Element.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Template\Internal\Element.o )
[44 of 53] Compiling Hakyll.Web.Template.Internal.Trim ( lib\Hakyll\Web\Template\Internal\Trim.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Template\Internal\Trim.o )
[45 of 53] Compiling Hakyll.Web.Template.Internal ( lib\Hakyll\Web\Template\Internal.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Template\Internal.o )
[46 of 53] Compiling Hakyll.Web.Template ( lib\Hakyll\Web\Template.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Template.o )
[47 of 53] Compiling Hakyll.Web.Template.List ( lib\Hakyll\Web\Template\List.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Template\List.o )
[48 of 53] Compiling Hakyll.Web.Feed  ( lib\Hakyll\Web\Feed.hs, .stack-work\dist\5c8418a7\build\Hakyll\Web\Feed.o )
Access violation in generated code when executing data at 0000000103644510</code></pre>
<ul>
<li><a href="https://github.com/jaspervdj/hakyll/issues/613" class="uri">https://github.com/jaspervdj/hakyll/issues/613</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/ticket/13112" class="uri">https://ghc.haskell.org/trac/ghc/ticket/13112</a></li>
</ul>
<p>hakyllをビルドしているときのメモリの様子を見ていると90%を超えています。 そのためただメモリが足りないためかもしれません。</p>
<p>TravisCIでやるとメモリに加えて時間もネックになってしまいそうなので、 <code>stack dot</code>を使って依存関係をグラフに変換した後、 特に依存関係が多いライブラリを探すと、 この逆の順序でビルドさせるのがよさそうだと思います。</p>
<ul>
<li>hakyll</li>
<li>pandoc</li>
<li>wai-app-static</li>
<li>wai-extra</li>
<li>http-conduit</li>
<li>tls</li>
</ul>
<h2 id="デプロイの方法">デプロイの方法</h2>
<p>GitHub Pagesを使います。gh-pagesやmasterそのものを使う方法もあるのですが、 masterのdocsフォルダの内部を参照する方法でいきます。</p>
<p>開発はdevelopブランチで行いますが、開発途中の物が公開されるのは困ります。 安全のために、surceブランチにマージしないとデプロイされないようにします。</p>
<p>サイトのソースはdocs-preに置いて、docsへと変換させます。</p>
<h2 id="テンプレート">テンプレート</h2>
<p>上で書いたことの作業を進めていて、 TravisCIに依存関係をキャッシュさせるのは成功しました。</p>
<p>次に始めたのはテンプレート作りです。HTMLやCSSについて必死に調べて、 Grid LayoutとかFlexboxを活用した結果、なんかそれっぽいものが完成しました。</p>
<p>グリッドで上下に区切って、上側に細いヘッダーを作り、 ヘッダーの一番左にアイコンを置いて、その右にFlexboxで等間隔にリンクを置いて、 下側は記事にして、左右に余白を作って、見出しの下にラインを入れただけです。</p>
<h2 id="hakyllのビルド">Hakyllのビルド</h2>
<p>いい加減、Hakyllを手元のWindowsが入ってるPCで動作させたいです。 手はいろいろ思いつきました。</p>
<dl>
<dt>そもそものバグを直す</dt>
<dd><p>コンパイラという深いところで発生するバグ、しかしもメモリがらみなので、 今の私の技術では無理でした。</p>
<p>せめて情報を集めることでバグが早く直るように、貢献しようとしたのですが、 stackの<code>ghc-options=(options)</code>を渡して情報を出力させようとしても、 情報が出力されないのかされているのかよくわかりませんでした。</p>
</dd>
<dt>GHCのメモリ使用量を減らす</dt>
<dd><p><code>Limiting GHC Memory</code>とかいうキーワードで検索したりしたのですが、 ほとんど情報は見つからず、無理なようです。</p>
<p>Stack Overflowに投稿された「GHCのメモリ使用量を制限する方法は？」という質問に まったく回答が付いていないのが哀愁を感じさせました。</p>
</dd>
<dt>分割コンパイル</dt>
<dd><p>Hakyllそのものを複数回に分けてコンパイル出来たらメモリ使用量も減るのでは、 という考えを持ったのですが、普通にはできないようです。</p>
<p>Hakyllに手を入れて、直接的に複数のライブラリに分けることを決めました。</p>
</dd>
<dt>フラグを操作してビルドするモジュールを減らす</dt>
<dd><p>Hakyllはたくさんフラグを持っていて、Pandocを使わなかったり、 プレビュー用のWebサーバーを使わなかったり、というときにフラグをオフにして、 無駄なコンパイルがされないように出来ます。</p>
<p>出来るだけフラグをオフにしたのですが、それでも無理でした。</p>
</dd>
</dl>
<p>ここで、有望そうなのはHakyllを複数のライブラリに分けることでした。</p>
<h2 id="hakyllの分割">Hakyllの分割</h2>
<p>コンパイルが失敗するのは<code>Hakyll.Core.***</code>が終わってから、 <code>Hakyll.Web.***</code>に入り始めたあたりなので、 そのあたりで分割することにしました。</p>
<p>まず、hakyll-coreというサブフォルダを作って、 <code>Hakyll.Core</code>以下のモジュールを全てそこに移動しました。 その後、cabalファイルもコピーしていらない設定を削除し始めたのですが、 どのファイルがいるのかいらないのかよくわからず進みませんでした。 そのため、テストとか実行ファイルとかWebサイトのサンプルは、 全て消した方がいいと思い直しました。ビルドしたいだけなのでいらないのです。</p>
<p>編集する前にリポジトリの状態を戻すコミットをした後、 ライブラリでないものをすべて削除してcabalファイルもそれに合わせて編集しました。 さらに、Paths_hakyllを消して、隠されたモジュールを全部公開しました。 後々困りそうなので先に処理しました。</p>
<p>その後、そもそものフォルダ構造をルートフォルダに一つのライブラリがある形から、 hakyll-coreとhakyllという二つのフォルダに二つのライブラリがある形にしました。</p>
<p>この時点で一回ビルドして、ファイルがないというエラーを見つけました。 本来は必要なのに消しすぎたということなので戻そうとしたのですが、 なぜか認識されませんでした。これはバグでした。 （ <a href="https://github.com/jaspervdj/hakyll/pull/645" class="uri">https://github.com/jaspervdj/hakyll/pull/645</a> ）</p>
<p>そして、メモリを使いすぎて落ちることなく、ビルドが成功しました！</p>
<p>ここまでの作業は<a href="https://github.com/jaspervdj/hakyll/compare/1abdeee743d65d96c6f469213ca6e7ea823340a7...2487d2ca77606da20986165ee57b3de22e311a02">1abdee...2487d2</a>で見れます。</p>
<h2 id="hakyllの修正">Hakyllの修正</h2>
<p>実行しようとしたらこのようなエラーが出てしまいました。</p>
<pre class="sourceCode text"><code>$ stack exec -- hexirp-blog-exe build
Initialising...
  Creating store...
  Creating provider...
  Running rules...
Checking for out-of-date items
Compiling
  [ERROR] docs-pre\articles/coq_pattern_match.rst: hGetContents: invalid argument</code></pre>
<p>パスがおかしくなってファイルを取得できていません。直さないといけないですね。</p>
<p>実行の流れを辿ってみました。最初の関数は<code>hakyllWith</code>です。 その後、色々なオプション付きの似たような関数を辿り、 <code>invokeCommands</code>にたどり着きました。 ここで、渡したオプションに応じて関数が呼ばれているようです。 渡したオプションはbuildだったので、それは<code>Commands.build</code>だと考えます。 <code>build</code>は<code>run</code>の簡単なラップで、 <code>run</code>はstoreの生成、providerの生成、ruleの設定DSLを走らせる、 それらを<code>build</code>（さっきとは別）で実行、結果に応じた後処理を行うようです。 storeは途中ファイルのキャッシュを担い、providerはサイトのソースを表します。</p>
<p>パスの問題に対処するには、おそらく、パスを読み込むときか、 それを使って処理するときのどっちかを直さないといけないと考えました。 私は本質的に直したいので、providerを生成する<code>newProvider</code>を見てみます。 それはinternalな方の<code>newProvider</code>を呼び出して後処理をするだけで、 それは生成するときに<code>getRecursiveContent</code>でコンテンツを取得して、 <code>getResourceInfo</code>で日時情報を取得して色々しています。</p>
<p>WindowsとLinuxはパスの区切りが違います。<code>\</code>と<code>/</code>ですね。 もし、ファイルパスを文字列で直接書けばどちらかにしか対応できません。 そこで、<code>System.FilePath</code>は<code>(&lt;\&gt;)</code>演算子を用意しています。 これは二つの文字列をパスの区切りを挟んで結合する単純な演算子ですが、 WindowsかLinuxかのどっちでコンパイルするかでパスの区切りが変わります。 よって、<code>(&lt;\&gt;)</code>を使っている関数は安全ということになります。</p>
<p>すぐ真下に定義があったため初めに目が留まったのは<code>getResourceInfo</code>で、 <code>docs-pre\articles/coq_pattern_match.rst</code>というパスを生成する物でした。 私はここまで<code>providerDirectory</code>に設定した<code>docs-pre</code>が使われている、 そのことに着目して追ってきました。そのコードは問題はないように見え、 行き詰ったように思えましたが、<code>toFilePath</code>を見てひらめきました。</p>
<p>hakyllは内部で<code>Identifier</code>という型でファイルパスで扱っています。 これは、きれいなファイルパスというようなもので、その変換時に問題がありました。 つまり、<code>fromFilePath</code>が直接<code>/</code>をパス区切りに使っていたのです。 （ <a href="https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Identifier.hs#L67" class="uri">https://github.com/jaspervdj/hakyll/blob/1abdeee743d65d96c6f469213ca6e7ea823340a7/lib/Hakyll/Core/Identifier.hs#L67</a> ）</p>
<p>直してやったのですが、エラーは出なくなった代わりに ファイルが認識されなくなってしまいました。</p>
<div class="note">
<div class="admonition-title">
<p>Note</p>
</div>
<p>プルリクエストは送り終えています （ <a href="https://github.com/jaspervdj/hakyll/pull/649" class="uri">https://github.com/jaspervdj/hakyll/pull/649</a> ）</p>
</div>
<h2 id="規則の書き方">規則の書き方</h2>
<p>Hakyllは規則をまとめて<code>hakyll</code>系関数に渡してやって実行するという形です。 規則は<code>Route</code>（どのファイルに出力するか）とか、 <code>Compiler</code>（どうやって変換するか）とか、色々織り込めるわけですが、 その規則を一部のファイルだけに適用することが出来る<code>match</code>という関数、 それが受け取るパスの書き方が問題でした。</p>
<p>つまり、Windowsで実行するのならばパス区切りに<code>\</code>を使わないといけない。 さて修正したところ、まだファイルが認識されません。</p>
<p><code>match pattern rule</code>と書いたとき、このパターンは独自の型なのですが、 <code>IsStrng</code>のインスタンスがあるため、文字列の形で書けます。 この時、裏で走るのは<code>fromGlob</code>という関数です。 パターンを直接組み立ててれば正規表現も使えたりするのですが、 文字列から暗黙的に変換するときはGlob記法しか使えないようです。</p>
<p>さて、このGlob記法にはエスケープが含まれていて、<code>\</code>という文字です。 つまり、<code>\</code>そのものを使いたいときは<code>\\</code>と書かないといけない。 さらにHaskellのソースコードにこれを書くために<code>\\\\</code>と書かないといけない。</p>
<p>修正したら無事ファイルが認識されてコンパイルできました。 ただしテンプレートが適用されていないのでのっぺりでした。</p>
<h2 id="テンプレートの適用">テンプレートの適用</h2>
<p>これも<code>match</code>と同じような罠がありましたので、 二つともまとめてヘルパー関数を作っておきました。 パスをリストで表すので何回もバックスラッシュを書く必要がなく、 さらにWindowsでもLinuxでも使えます。</p>
<p>さてコンパイルしようとしたところ、 「テンプレートの穴が開いているところは埋められなければならない」 このルールに引っかかって動作させることが出来ませんでした。 穴は文脈から埋められるのですが、その文脈を作るのが難しい。 というか、Pandocで定義される<a href="https://pandoc.org/MANUAL.html#extension-yaml_metadata_block">yaml_metadata_block</a>で文脈を定義して、 それを取り出すのが定石なのですが、これが好きではない。 とりあえず黙認値で埋めときました。</p>
<h2 id="stackのresolverの更新">stackのresolverの更新</h2>
<p>resolverは早め早めに更新しないと後で困ります。 更新したら変なエラーが出てしまいました。 （ <a href="https://travis-ci.org/Hexirp/blog/builds/400810238" class="uri">https://travis-ci.org/Hexirp/blog/builds/400810238</a> ）</p>
<ul>
<li><a href="https://github.com/jaspervdj/hakyll/issues/629" class="uri">https://github.com/jaspervdj/hakyll/issues/629</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4071" class="uri">https://github.com/commercialhaskell/stack/issues/4071</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4111" class="uri">https://github.com/commercialhaskell/stack/pull/4111</a></li>
</ul>
<p>つまり、最後のプルリクエストでこのエラーは解決しています。 しかし、それはまだリリースされているstackに含まれていません！ resolverの更新はしばらく待つ必要がありそうです。</p>
<h2 id="デプロイ">デプロイ</h2>
<p>デプロイをしようと思いました。</p>
<p>まず、sourceブランチでビルドしたものを、 masterブランチにプッシュする形にしようと思いました。 しかし、これではmasterブランチからsourceブランチへのコミットが辿れず、 どれだけコミットをしても芝生が生えません。</p>
<p>上の形に加えてsourceブランチをmasterブランチにマージすることにしました。 masterブランチからマージするとき、全てをsourceブランチと同じにしたいのですが、 <code>-s theirs</code>というオプションはありません。 結局source側から<code>-s ours</code>を使ってマージすることにしました。 さらに、コマンドが失敗したら終わりにしたいから<code>set -eu</code>したり、 <code>&amp;&gt; /dev/null</code>というようにトークンを使うコマンドの出力を、 /dev/null送りの刑に処したりいろいろありましたが出来ました。</p>
<p>TravisCIのビルドがなぜかキャッシュを読み込まず、 一からライブラリをビルドしようとしていて落ちました。</p>
<h2 id="travisciのキャッシュ">TravisCIのキャッシュ</h2>
<p>原因はデフォルトブランチをmasterからdevelopに置き換えていたことでした。</p>
<p>TravisCIは通常のコミットに対するビルドの時、 第一にそのブランチに付随するキャッシュを読み込もうとします。 それがなかったら次にデフォルトブランチのキャッシュを読み込もうとします。 （今までは何となく派生元ブランチだと思っていました）</p>
<p>そして、masterブランチにはあらかじめ用意して置いたキャッシュがあります。 今までのすべてのビルドはこのキャッシュを読み込んでいたのでした。 そして、developブランチのキャッシュは存在しなかったため、 置き換えたときにビルドが失敗するようになったのです。 しかし、私はdevelopブランチのキャッシュがあるから大丈夫だと思っていました。</p>
<p>ないのにあると思っていたわけは、 あるブランチでのビルドがそのキャッシュを読み込んでビルドを成功させたとき、 そのキャッシュは改めてそのブランチのキャッシュとして追加されると、 勝手に思っていたためでした。 つまり、masterブランチのキャッシュがsoruceブランチ、developブランチ、 そのほかのキャッシュとして伝道されていくイメージでした。 しかし、そのビルドにおいてキャッシュに変更がないとき、 そのブランチのキャッシュとして追加されません。 developブランチのキャッシュは存在しないままでした。</p>
<p>masterブランチをデフォルトに戻しました。</p>
    </main>
  </body>
</html>
