# オブジェクトはコモナドなのか？

この記事は致命的な誤りにより放棄されています。

## オブジェクトとは？

ここでは、オブジェクトは Java ライクなものとして考えます。

## オブジェクトの本質とは？

副作用は本質ではありません。継承は本質ではありません。名前空間は本質ではありません。

そうすると、オブジェクトは、フィールドの型に自分自身が使われているかもしれないレコード型です。次のように例を示します。

```elm
type Integer_Object
  =
    {
      value : Integer
    ,
      successor : Unit -> Integer_Object
    ,
      plus : Integer -> Integer_Object
    }
```

## オブジェクトの形式化とは？

メソッドを列挙する時の添字の型を `Index : Type` とします。メソッドの型を `Method : Index -> Type -> Type` とします。

`Record : (Index : Type) -> (Field : Index -> Type) -> Type` を使って `Object Index Method = Record Index (i : Index => Method i (Object Index Method))` とオブジェクトを表せます。

余談ですが、 `Method` が第二引数において強く正でない時にも `Object` が存在するとすると、カリー・ハワード対応で論理体系として見なした時に矛盾を起こします。

## 自由コモナドとは？

## オブジェクトはコモナドなのか？

`F = A : Type => Record Index (i : Index => Method i A)` が関手であるとき、これを使って自由コモナドを生成できます。具体的には `O = Cofree F` のようにします。 `O Unit` は元々のオブジェクトと同型になります。これを持ってオブジェクトはコモナドと言えるように思えます。

では、そんなに都合よく `F` が関手になるものなのでしょうか？ いえ、なりません。たとえば、 Java での `Object.equals(Object)` のようなメソッドがある時は関手になりません。 `Object -> A` のように自分自身の型が負の位置に現れるからです。

## メソッドの型は共変でなければならない。

しかし、 `Object.equals(Object)` は継承を行ったときの実装が厄介なメソッドです。そして、型クラスのように `A -> A -> Bool` という関数に比較を任せる方が美しい実装となります。

すると、 `Object.equals(Object)` のような型を持つメソッドは存在してはいけないと逆に考えることも出来るのではないでしょうか。そう、メソッドの型は共変でなければならないのです。その方が美しいのです。

継承を考えに入れても、メソッドの型は共変である方が良いです。 `A` を `A_` が継承するとします。 `A` が `Integer -> A` というメソッドを持っているとすると、 `A_` では `Integer -> A_` となり、自然に拡張できます。その一方で、 `A` が `A -> Integer` というメソッドを持っているとすると、 `A_` では `A_ -> Integer` となり、自然に拡張できません。

オブジェクトはコモナドです。そして、メソッドの型は共変でなければなりません。
