---
title: チャンパーノウン定数を作ってみた
description: >-
 題の通りチャンパーノウン定数の桁を無限リストで表現したものを Haskell で実装し、
 その効率を測って直感と合うかどうか確かめてみるだけの記事です。
canonical: 'https://hexirp.github.io/blog/articles/champernowne.html'
type: article
...

################################
チャンパーノウン定数を作ってみた
################################

題の通りチャンパーノウン定数の桁を無限リストで表現したものを Haskell で実装し、
その効率を測って直感と合うかどうか確かめてみるだけの記事です。

****
動機
****

チャンパーノウン定数は疑似乱数としても使えるらしいので作ってみようかなーと。

**********
プログラム
**********

基本的な発想はこんな感じです。

.. code-block:: text

 [1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, ...]

 [1] ++ [1, 0, 1, 1] ++ [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1] ++ ...

 concatMap (1 :) [[]] ++
 concatMap (1 :) [[0], [1]] ++
 concatMap (1 :) [[0, 0], [0, 1], [1, 0], [1, 1]] ++
 ...

これをそのまま実装してみたのがこれ。

.. code-block:: haskell

 champernowne :: [Bool]
 champernowne = concat cham_sep

 -- champernowne + separated
 cham_sep :: [[Bool]]
 cham_sep = map cham_piece [0 :: Integer ..]

 -- champernowne + piece
 cham_piece :: Integer -> [Bool]
 cham_piece = concat . map (True :) . pows

 pows :: Integer -> [[Bool]]
 pows 0 = [[]]
 pows n = (:) <$> [False, True] <*> pows (n - 1)

``pows`` が非直感的かもしれませんが、n桁のビット列全てのリストを返します。

****
予測
****

ざっくり考えるとこんな感じになると思います。

メリット
 * 繰り返しがない
 * 全てのパターンが必ず現れる

デメリット
 * 値を取り出し続けると計算量が増える（おそらく log n に比例して）
 * 繰り返し計算ではないため最適化が効きづらい？

実際に GHCi で遊んでみます。\ ``let f x = if x then '1' else '0'`` を
入力してやって、その関数を ``map`` して無限リストを文字列に変換してから
表示してみます。遅延評価なので次々と次の桁が計算されてすぐさま表示されます。
眺めているとこんなデメリットがあるっぽいのを発見しました。

デメリット
 * 実用的に見ると結構規則性がある

最初の数千桁を取り出したぐらいでは、連結されていくリストの最初の要素が
必ず1になるが故に、一定間隔で必ず1になってしまうようです。これを掻き消すには
数億桁取り出しても足りないかもしれません。（その間隔の増加速度が対数的なので）

効率のほうは徐々に遅くなっているように見えますがはっきりしたことは分かりません。
特に Haskell では「実際に測ってみないことにはわからない」ので測ってみます。
取り出し続けると log n に比例して遅くなっていくことを確かめることが目的です。

****
実験
****

あるn桁まで計算したとき、次の(n+1)桁を取り出すための計算量が log n であると
予測します。この予測に従うと、n桁までの計算量は積分で n log n になるはずです。
これを確認します。次の桁を取り出すのにかかる時間を直接測定しない理由は
それぞれの断片 (``cham_piece``) を結合した境目などでむらがあると考えられるため
です。

Haskell の計測に関するデファクトスタンダードは criterion です。使いましょう。

.. code-block:: haskell

 import Criterion.Main

 -- 上のコードスニペットをここに

 main :: IO ()
 main = do
  x <- defaultMain [
   bgroup "cham" [
    bench "10000" $ nf cham 10000,
    bench "100000" $ nf cham 100000,
    bench "1000000" $ nf cham 1000000]
   ]
  return x

 cham :: Int -> [Bool]
 cham x = take x champernowne

さて、他のプログラムをすべて終了させて計測してみます。

.. code-block:: text

 benchmarking cham/10000
 time                 431.0 μs   (425.5 μs .. 436.3 μs)
                      0.998 R²   (0.997 R² .. 0.999 R²)
 mean                 434.3 μs   (429.6 μs .. 442.4 μs)
 std dev              20.14 μs   (14.26 μs .. 32.38 μs)
 variance introduced by outliers: 41% (moderately inflated)

 benchmarking cham/100000
 time                 3.885 ms   (3.811 ms .. 3.972 ms)
                      0.996 R²   (0.993 R² .. 0.998 R²)
 mean                 3.877 ms   (3.832 ms .. 3.931 ms)
 std dev              159.0 μs   (126.5 μs .. 196.8 μs)
 variance introduced by outliers: 23% (moderately inflated)

 benchmarking cham/1000000
 time                 41.30 ms   (40.05 ms .. 42.72 ms)
                      0.995 R²   (0.985 R² .. 1.000 R²)
 mean                 40.50 ms   (40.01 ms .. 41.66 ms)
 std dev              1.394 ms   (656.2 μs .. 2.379 ms)

はい、何もわかりませんね。ただ、時間を測るのには100000がちょうど良さそうです。
解像度を上げてみます。100000から1000000まで10000刻みにして11のケースを作ります。
ついでに ``--output FILE`` オプションを使ってHTMLファイルで結果を出力させます。

`結果 (100000, 200000 .. 1000000) </blog/articles/champernowne/result_1.html>`_
 さらに調べる範囲を広げるとこのようになりました。

`結果 (100000, 200000 .. 1900000) </blog/articles/champernowne/result_2.html>`_
 線形時間であるように見えます。log n の増加率はとても小さいからかもしれません。
 なんとか log n がはっきりわかるようなグラフが欲しいのでnを10倍にします。

`結果 (1000000, 2000000 .. 19000000) </blog/articles/champernowne/result_3.html>`_
 まっすぐにしか見えません。log n の影響は小さくてほぼ線形ということでしょうか？
 ここで log n の影響は初めの方が大きくなることに気が付きました。
 つまり、二階微分、曲率っぽいものが大きくなることです。

`結果 (10000, 20000, .. 190000) </blog/articles/champernowne/result_4.html>`_
 まだよくわかりません。もういっちょ小さくしてみましょう。

`結果 (1000, 2000, .. 19000) </blog/articles/champernowne/result_5.html>`_
 諦めます。ほぼ線形時間ということでいいと思います。

次の(n+1)桁を取り出すための計算量を直接測ってみようと思ったのですが、
前に同じようなことを考えて、それぞれの断片に差し掛かったときに展開されて
スパイク状に計算量が上がると考えられるため、無意味だと考えてやめたんでした。

と、ここで気が付いてしまったのですが、このスパイク状に上がる計算量は、
log n に比例して高さが大きくなるはずで、それが計算量が n log n だと判断した
根拠なのですが、他の要素を取り出すときに必要な計算量を一時点に
集めているだけなので分配したらフラットになるのでは。

これが正しければ、正真正銘の線形時間であることになります。

****
考察
****

さっきの考えは整理するとこんな感じになります。

+----------------------------------+----------------------------+
| 取り出そうとしているのが何個めか | 取り出すまでにかかるコスト |
+==================================+============================+
| 1                                | 1                          |
+----------------------------------+----------------------------+
| 2                                | 2                          |
+----------------------------------+----------------------------+
| 3                                | 0                          |
+----------------------------------+----------------------------+
| 4                                | 1                          |
+----------------------------------+----------------------------+
| 5                                | 0                          |
+----------------------------------+----------------------------+
| 6                                | 3                          |
+----------------------------------+----------------------------+
| 7                                | 0                          |
+----------------------------------+----------------------------+
| 8                                | 1                          |
+----------------------------------+----------------------------+
| 9                                | 0                          |
+----------------------------------+----------------------------+
| 10                               | 2                          |
+----------------------------------+----------------------------+
| 11                               | 0                          |
+----------------------------------+----------------------------+
| 12                               | 1                          |
+----------------------------------+----------------------------+
| 13                               | 0                          |
+----------------------------------+----------------------------+

こんな感じでコストがあり、均すと定数時間になるという考え方です。

最初は、それぞれの断片をリスト結合が節である木として考え、そのn番目の断片の
木としての高さが log n であるため、次の桁を取り出すのにかかる時間は
平均して log n だ！という考え方をしていました。なんて安直な。

n番目の断片に含まれるリスト結合は(2^n-1)個であり、それらを(2^n)個の要素が
分散して負担するため、次の桁を取り出すのにかかる時間は平均して定数時間になると
考えられます。

********
終わりに
********

結局、桁が進むとメモリや可変長整数の可算などが絡んで準線形時間になる気がします。

余談だが、OEIS で検索してみるとリストの先頭に 0 を置くかどうかで二種類ある。
この記事の意図はチャンパーノウン定数の「小数部」の桁を表示するプログラムなので、
0 を置かない方が正しい。後で気が付いたのだが、こっちの方がプログラムが美しいので
まあいいやってなった。
