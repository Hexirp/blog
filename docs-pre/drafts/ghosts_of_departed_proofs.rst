#########################
Ghosts of Departed Proofs
#########################

``head`` みたいな全ての入力に対して出力があるとは限らない関数を定義したいときに
どうしますか？ 普通は部分関数にするか ``Maybe`` なんなりの失敗を表現できる
何かを使って定義しますよね。でも、部分関数は苛立たしい実行時エラーを引き
起こします。Maybe など安全な方法を取っても、「なんでこれ失敗するの！？」と
いうような時があります。原因を調べるためには、ドキュメントやソースコードを
調べる必要があり無駄な苦労をすることがあります。即ち、どちらの選択肢も
理想的ではありません。

この問題を解決する方法の一つが "Ghosts of Departed Proofs" です。核となる発想は
幽霊型の newtype ラッパーを使うことで、余分な型引数によって高度な事前条件を
オーバーヘッドなしに Haskell の型システムで表現できることであり、ユーザーは
幽霊型によって表現された事前条件を証明することで、引数が正しいものであると
コンパイラに主張します。

"Ghosts of Departed Proof" は Haskell 2010 に対する簡易な拡張のみを使って、
依存型 (dependent type) や篩型 (refinement type) のいくつかの利点を得られると
いう点で、他の方法よりも優位性を持っています。この記事では、リストやマップや
共有メモリ領域やその他へ不変条件を課する例を紹介することで "Ghosts of Departed
Proofs" を段階的に説明していきたいと思います。
