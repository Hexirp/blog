################################
チャンパーノウン定数を作ってみた
################################

題の通りチャンパーノウン定数の桁を無限リストで表現したものを Haskell で実装し、
効率を測って直感と合うかどうか確かめてみるだけの記事です。

****
動機
****

チャンパーノウン定数は疑似乱数としても使えるらしいのでやってみようかなーと。

**********
プログラム
**********

基本的な発想はこんな感じです

.. code-block:: text

 [1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, ...]

 [1] ++ [1, 0, 1, 1] ++ [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1] ++ ...

 concatMap (1 :) [[]] ++
 concatMap (1 :) [[0], [1]] ++
 concatMap (1 :) [[0, 0], [0, 1], [1, 0], [1, 1]] ++
 ...

これをそのまま実装してみたのがこれ。

.. code-block:: haskell

 champernowne :: [Bool]
 champernowne = concat cham_sep

 -- champernowne + separated
 cham_sep :: [[Bool]]
 cham_sep = map cham_piece [0 :: Integer ..]

 -- champernowne + piece
 cham_piece :: Integer -> [Bool]
 cham_piece = concat . map (True :) . pows

 pows :: Integer -> [[Bool]]
 pows 0 = [[]]
 pows n = (:) <$> [False, True] <*> pows (n - 1)

``pows`` が非直感的かもしれませんが、n桁のビット列全てのリストを返します。

****
性質
****

さっくり考えるとこんな感じになると思います。

メリット
 * 繰り返しがない
 * 全てのパターンが必ず現れる

デメリット
 * 値を取り出し続けると計算量が増える（おそらく log n に比例して）

実際に GHCi で遊んでみます。\ ``let f x = if x then '1' else '0'`` を
入力してやって、その関数を ``map`` して無限リストを文字列に変換してから
表示してみます。遅延評価なので次々と次の桁が計算されてすぐさま表示されます。
眺めているとこんなデメリットがあるっぽいです。

デメリット
 * 実用的に見ると結構規則性がある

最初の数千桁を取り出したぐらいでは、連結されていくリストの最初の要素が
必ず1になるが故に、一定間隔で必ず1になってしまうようです。これを掻き消すには
数億桁取り出しても足りないかもしれません。（対数的なので）

効率のほうは徐々に遅くなっているように見えますがはっきりしたことは分かりません。
特に Haskell では「実際に測ってみないことにはわからない」ので測ってみます。
