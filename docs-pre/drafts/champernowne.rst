################################
チャンパーノウン定数を作ってみた
################################

題の通りチャンパーノウン定数の桁を無限リストで表現したものを Haskell で実装し、
効率を測って直感と合うかどうか確かめてみるだけの記事です。

****
動機
****

チャンパーノウン定数は疑似乱数としても使えるらしいのでやってみようかなーと。

**********
プログラム
**********

基本的な発想はこんな感じです

.. code-block:: text

 [1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, ...]

 [1] ++ [1, 0, 1, 1] ++ [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1] ++ ...

 concatMap (1 :) [[]] ++
 concatMap (1 :) [[0], [1]] ++
 concatMap (1 :) [[0, 0], [0, 1], [1, 0], [1, 1]] ++
 ...

これをそのまま実装してみたのがこれ。

.. code-block:: haskell

 champernowne :: [Bool]
 champernowne = concat cham_sep

 -- champernowne + separated
 cham_sep :: [[Bool]]
 cham_sep = map cham_piece [0 :: Integer ..]

 -- champernowne + piece
 cham_piece :: Integer -> [Bool]
 cham_piece = concat . map (True :) . pows

 pows :: Integer -> [[Bool]]
 pows 0 = [[]]
 pows n = (:) <$> [False, True] <*> pows (n - 1)

``pows`` が非直感的かもしれませんが、n桁のビット列全てのリストを返します。

****
性質
****

さっくり考えるとこんな感じになると思います。

メリット
 * 繰り返しがない
 * 全てのパターンが必ず現れる

デメリット
 * 値を取り出し続けると計算量が増える（おそらく log n に比例して）

実際に GHCi で遊んでみます。\ ``let f x = if x then '1' else '0'`` を
入力してやって、その関数を ``map`` して無限リストを文字列に変換してから
表示してみます。遅延評価なので次々と次の桁が計算されてすぐさま表示されます。
眺めているとこんなデメリットがあるっぽいです。

デメリット
 * 実用的に見ると結構規則性がある

最初の数千桁を取り出したぐらいでは、連結されていくリストの最初の要素が
必ず1になるが故に、一定間隔で必ず1になってしまうようです。これを掻き消すには
数億桁取り出しても足りないかもしれません。（対数的なので）

効率のほうは徐々に遅くなっているように見えますがはっきりしたことは分かりません。
特に Haskell では「実際に測ってみないことにはわからない」ので測ってみます。
目的は、\ log n に比例して遅くなっていくことを確かめることです。

****
計測
****

あるn桁まで計算したとき、次の(n+1)桁を取り出すための計算量が log n であると
予測します。この予測に従うと、n桁までの計算量は積分で n log n になるはずです。

Haskell の計測に関するデファクトスタンダードは criterion です。使いましょう。

.. code-block:: haskell

 import Criterion.Main

 -- 上のコードスニペットをここに

 main :: IO ()
 main = do
  x <- defaultMain [
   bgroup "cham" [
    bench "10000" $ nf cham 10000,
    bench "100000" $ nf cham 100000,
    bench "1000000" $ nf cham 1000000]
   ]
  return x

 cham :: Int -> [Bool]
 cham x = take x champernowne

さて、他のプログラムをすべて終了させて計測してみます。

.. code-block:: text

 benchmarking cham/10000
 time                 431.0 μs   (425.5 μs .. 436.3 μs)
                      0.998 R²   (0.997 R² .. 0.999 R²)
 mean                 434.3 μs   (429.6 μs .. 442.4 μs)
 std dev              20.14 μs   (14.26 μs .. 32.38 μs)
 variance introduced by outliers: 41% (moderately inflated)

 benchmarking cham/100000
 time                 3.885 ms   (3.811 ms .. 3.972 ms)
                      0.996 R²   (0.993 R² .. 0.998 R²)
 mean                 3.877 ms   (3.832 ms .. 3.931 ms)
 std dev              159.0 μs   (126.5 μs .. 196.8 μs)
 variance introduced by outliers: 23% (moderately inflated)

 benchmarking cham/1000000
 time                 41.30 ms   (40.05 ms .. 42.72 ms)
                      0.995 R²   (0.985 R² .. 1.000 R²)
 mean                 40.50 ms   (40.01 ms .. 41.66 ms)
 std dev              1.394 ms   (656.2 μs .. 2.379 ms)

はい、何もわかりませんね。ただ、時間を測るのには100000がちょうど良さそうです。
解像度を上げてみます。100000から1000000まで10000刻みにして11のケースを作ります。
ついでに ``--output FILE`` オプションを使ってHTMLファイルで結果を出力させます。

`結果 (100000, 200000 .. 1000000) </blog/champernowne/result_1.html>`_

さらに調べる範囲を広げるとこのようになりました。

`結果 (100000, 200000 .. 1900000) </blog/champernowne/result_2.html>`_

線形時間であるように見えます。log n の増加率はとても小さいためです。
なんとか log n がはっきりわかるようなグラフが欲しいのでnを10倍にします。

`結果 (1000000, 2000000 .. 19000000) </blog/champernowne/result_3.html>`_

まっすぐにしか見えません。log n の影響は小さくてほぼ線形ということでしょうか？
ここで log n の影響は小さいほうが大きくなることにようやく気が付きました。
つまり、二階微分、曲率っぽいものが大きくなることです。小さくしてみます。

`結果 (10000, 20000, .. 190000) </blog/champernowne/result_4.html>`_

まだよくわかりません。もういっちょ小さくしてみましょう。

`結果 (1000, 2000, .. 19000) </blog/champernowne/result_5.html>`_

諦めます。ほぼ線形時間ということでいいと思います。

次の(n+1)桁を取り出すための計算量を直接測ってみようと思ったのですが、
前に同じようなことを考えて、それぞれの断片が展開されるときにスパイク状に
計算量が上がると考えられるため、無意味だと考えてやめたんでした。

と、ここで気が付いてしまったのですが、このスパイク状に上がる計算量は、
log n に比例して高さが大きくなるはずで、それが計算量が n log n だと判断した
根拠なのですが、他の要素を取り出すときに必要な計算量を一時点に
集めているだけなので分配したらフラットになるのでは。

これが正しければ線形時間になるのでは。

****
修正
****

さっきの考えは整理するとこんな感じになります。

================================ ==========================
取り出そうとしているのが何個めか 取り出すまでにかかるコスト
================================ ==========================
1                                1
2                                2
3                                0
4                                1
5                                0
6                                3
7                                0
8                                1
9                                0
10                               2
11                               0
12                               1
13                               0
================================ ==========================

こんな感じでコストがあり、均すと定数時間になるという考え方です。
断片が指数関数的に大きくなっていくのに惑わされてしまっていました。
