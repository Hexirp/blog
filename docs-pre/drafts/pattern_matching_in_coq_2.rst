##########################
Coq でのパターンマッチング
##########################

.. highlight:: coq

Coq は代数的データ型 (ADT / Algebraic data type) のようにして新しい型を定義
でき、さらに一般化代数的データ型 (GADT / Generalized algebraic data type) や
依存型もモリモリ使える、という言語です。たいへん良いですね。しかしながら、
それが複雑化して、パターンマッチングをどうやればいいのか、それで何が起こるの
か、どう型付けされるのか、素朴に理解できませんでした。この記事は、それらを理解
したいがためのメモです。Haskell を知っているが Coq はよくわからない人
（＝自分）のために書いてあります。

*********
inversion
*********

``inversion`` タクティックは非自明な動きをするタクティックとして槍玉に
あげられています。（調査対象：自分）。

しかし ``simpl`` タクティックや ``intro`` タクティック、\ ``subst`` 
タクティック、\ ``discriminate`` タクティックを勝手に適用することを除けば、
基本的なアイデアは先ほど書いたものだけです。

即ち、ゴール ``Vec A M -> B`` があったとき、ゴールを
``forall n, Vec A n -> n = M -> B`` と書き換えてやり、普通の
パターンマッチングを行うことです。その結果、ゴールは二つのゴールに分かれ、
``0 = M -> B`` と ``forall np, A -> Vec A np -> S np = M -> B`` となります。

例えば ``forall m n, Vec A m -> Vec A n -> Vec A (m + n)`` を定義することを
考えましょう。まずは "intro" しましょう。

.. code-block:: none

 A : Type
 m : nat
 n : nat
 x : Vec A m
 y : Vec A n
 ------------------------
 Vec A (m + n)

この時 "inversion" によって以下の場合に分けることが出来ます。

.. code-block:: none

 A : Type
 m : nat
 n : nat
 y : Vec A n
 H : 0 = m
 ------------------------
 Vec A (m + n)
