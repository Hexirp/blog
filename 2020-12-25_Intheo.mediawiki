Intheo というプログラミング言語を自作しています。自作プログラミング言語が茨の道であることはよく知られている通りですが、それでも自作しようと思った理由は、 Coq での余帰納型の扱いが悪すぎるということに尽きます。そこで、余帰納型の扱いが良い言語を作るついでに、色々なアイデアを詰め込んでみようというのが始まりです。

Intheo は "in theory" に由来します。当面の実装に使用している言語は Haskell ですが、効率を上げるために Rust を使ったり形式的な検証を行うために Coq を使ったりするかもしれません。

== 余帰納型 ==

余帰納型は、英語では coinductive type と言います。 Haskell では余帰納型という言葉は意味を持ちません。 Coq や Agda のような停止性が保証されていなければならない言語において、その意味を持ち始めます。その名前の通り余帰納法に関係していますが、私の印象としては余帰納法を理解しなくても余帰納型を理解することが出来ます。

Coq における余帰納型についての信頼できる文献としては [https://coq.inria.fr/refman/language/core/coinductive.html Co-inductive types and co-recursive functions — Coq 8.12.2 documentation] ([https://web.archive.org/web/20201104192956/https://coq.inria.fr/refman/language/core/coinductive.html archive]) と [http://adam.chlipala.net/cpdt/html/Coinductive.html Chapter 5 Infinite Data and Proofs — Certified Programming with Dependent Types] ([https://web.archive.org/web/20200216183013/http://adam.chlipala.net/cpdt/html/Coinductive.html archive]) があります。両方とも英語で書かれており、日本語で解説したほうが読者には親切なのでしょうが、この記事の主題から外れますので、機会があったら別の記事として書きたいと思います。

<syntaxhighlight lang="coq">
CoInductive CoNat : Type := coZero : CoNat | coSucc : CoNat -> CoNat.
</syntaxhighlight>

余帰納型の定義の例を上記で示しました。この時点で、既に大きな問題があることが分かります。それは定義が「和」ベースになっていることです。どういうことかというと、帰納型はよく知られているようにコンストラクタにより直和型に似たものを作るのですが、余帰納型は直積型に似たものであるべきなのです。

{|
|-
| 帰納型 (inductive type)
| 余帰納型 (coinductive type)
|-
| 構築子 (constructor)
| 分解子 (destructor)
|-
| 場合分け (pattern matching)
| 余場合分け (copattern matching)
|-
| 帰納法の原理 (principle of induction)
| 余帰納法の原理 (principle of coinduction)
|-
| 直和 (sum)
| 直積 (product)
|}

美しくも圏論において帰納型と余帰納型は双対になりますが、その対応関係は上記のようになります。このことから分かるように余帰納型は分解子から構成されるべきなのですが、 Coq ではそうなっていません。

<syntaxhighlight lang="coq">
CoInductive Stream (A : Type) : Type :=
  & head : Stream A -> A
  & tail : Stream A -> Stream A.
</syntaxhighlight>

上記のように書かれるべきなのではないでしょうか？ Intheo はこのような構文を持つ言語が欲しくて制作し始めたものです。

== 余場合分け ==

当然のことながら、分解子だけでは余帰納型を扱うことは出来ません。項の組み立ての方法が必要になります。これには前記の表に乗せた余場合分けが必要になります。

<syntaxhighlight lang="coq">
comatch
  & head := 0
  & tail := mapStream (plus 1) natStream
end
</syntaxhighlight>

仮想的に構文を設定すると上記のようになるでしょう。ただし、レコードの生成と同一の構文になるなどの選択の余地はあります。

== バリアント型 ==

型の定義において、帰納型と余帰納型は、定義にその型自身が現れるのを許容します。これを「再帰的な型の定義」と呼びます。一方で、定義に自分自身が現れない型もあり、これらは特別な扱いを受けるべきです。

{|
!
! 帰納的
! 余帰納的
|-
! 非再帰的
| バリアント型 (variant type)
| 余バリアント型 (covariant type)
|-
! 再帰的
| 帰納型 (inductive type)
| 余帰納型 (coinductive type)
|}

上記のように型の定義を分類すべきだと考えます。これを組み入れた言語を作るのも面白いでしょう。

== 評価戦略 ==

Intheo は停止性を保証する言語であり、強正規化性 (strong normalization property, SN) を持たなければなりません。ここで、 SN は「どのようなルートを辿って簡約していっても簡約不能形／正規形に行き着く」という性質のことを指します。よって、 Intheo の簡約の順序には自由性が確保されています。

では、どのように簡約していけばいいのでしょうか？ すぐわかることとしては、余帰納型の <code>cofix</code> 式を正格に簡約しては容易に無限ループになってしまうということです。よって、余帰納型の <code>cofix</code> 式の簡約は遅延しなければなりません。また、 <code>comatch</code> 式も同様に遅延すべきでしょう (lazy な型を定義する手段が欲しいため、あるいは <code>tail : forall (x : Stream A), P x</code> というような型のデストラクタに備えて) 。

{|
|-
| 帰納型 (inductive type)
| 余帰納型 (coinductive type)
|-
| 構築子 (constructor)
| 分解子 (destructor)
|-
| 場合分け (pattern matching)
| 余場合分け (copattern matching)
|-
| 帰納法の原理 (principle of induction)
| 余帰納法の原理 (principle of coinduction)
|-
| 直和 (sum)
| 直積 (product)
|-
| strict
| lazy
|-
| call-by-value
| call-by-name
|-
| 依存和型 (dependent sum type) / 直積型 (product type)
| 依存積型 (dependent product type) / 関数型 (function type)
|-
|}

call-by-value と call-by-name は双対になっていることが知られています。当然、 call-by-value は strict であり call-by-name は lazy です。

<syntaxhighlight lang="coq">
CoVariant Prod (A : Type) (B : Type) : Type :=
  & fst : Prod A B -> A
  & snd : Prod A B -> B.

Axiom A : Type.
Axiom a : A.
Axiom B : Type.
Axiom b : B.

Check fst A B (comatch fst := a & snd := b end) : A.
(*
  fst A B (comatch fst := a & snd := b end)
  a
*)
</syntaxhighlight>

上記のように簡約が行われます。ここで、 <code>cofix</code> 式と <code>comatch</code> 式は分解子により直接分解されない限り、簡約することは出来ません。ちょうど <code>match x with ... end</code> が <code>x</code> が何か分からないと簡約できないことの双対です。

基本的に call-by-value では <code>f x</code> のような適用は <code>x</code> を完全に簡約してから <code>f</code> との β 簡約が行われます。しかし、 <code>x</code> が <code>cofix</code> 式または <code>comatch</code> 式になった時は <code>x</code> の簡約が停止し、そのまま <code>f</code> との β 簡約が行われます。その例外は <code>f</code> が分解子である時であり、 <code>cofix</code> 式または <code>comatch</code> 式の分解が行われます。

なお、上記の表にあるように関数型も遅延して評価されます。直積型については表の左右どちらにも表れているように lazy サイドとも strict サイドとも解釈できます。

== レコード型 ==

「評価戦略」の節で余帰納型は遅延評価されると説明しました。それは、バリアント型と余バリアント型のどちらでも定義可能な型において、正格性の違いをもたらします。

<syntaxhighlight lang="coq">
CoVariant Prod (A : Type) (B : Type) : Type :=
  & fst : Prod A B -> A
  & snd : Prod A B -> B.

Variant Prod (A : Type) (B : Type) : Type :=
  | pair : A -> B -> Prod A B.
</syntaxhighlight>

上記の二つの型は同じものを表しますが、その正格性だけが異なります。つまり、直積をベースにした正格な型を定義したいという需要があることになります。

<syntaxhighlight lang="coq">
Record Prod (A : Type) (B : Type) : Type :=
  pair { fst : A; snd : B }.
</syntaxhighlight>

上記のように書けるようにすることで、直積をベースにした正格な型を簡単に定義できるようにします。

== 失敗を許容する文法 ==

プログラミング言語には文法がつきものです。文法がないプログラミング言語は考えられないほどです。あるんですが。

<syntaxhighlight lang="bnf">
<term> ::= "(" <term> ")" <term> | ""
</syntaxhighlight>

これは括弧しか持たない単純な言語を表します。たとえば、 <code>()()(()</code> という文は、この言語として正しくありません。括弧が一つ足りないためです。

<syntaxhighlight lang="bnf">
<term> ::= "(" <term> ")" <term> | "" | "(" <term>
</syntaxhighlight>

上記のように改変してみればどうでしょうか？ <code>()()(()</code> という文も受理されます。問題が起きるように見えますが、受理した後に三番目のルールを使う文法木を弾けばいいのです。

これが失敗を許容する文法です。主なメリットとしてはエラーメッセージの改善が期待されます。これのために、失敗が存在しない専用のパーサーコンビネーターも実装する予定です。それは <code>RWST</code> と等しいものであり、 <code>onHold</code> という関数でバックトラッキングも出来るようになっています。

== 道型 ==

Homtopy Type Theory / Cubical Type Theory との親和性のために、道型はプリミティブであるべきでしょう。

<syntaxhighlight lang="coq">
Inductive Path (A : Type) (x : A) : A -> Type :=
  | idpath : Path A x x.
</syntaxhighlight>

上記のように道型を再定義することも出来るのでプリミティブである必要はないと思われるかもしれませんが、そもそもこのように書くことが出来ないようにします。

<syntaxhighlight lang="coq">
Inductive Even : Nat -> Type :=
  | even_zero : Even zero
  | even_succ_succ_n : forall n : Nat, Even n -> Even (succ (succ n)).

Inductive Even (n : Nat) : Type :=
  | even_zero : n = zero -> Even n
  | even_succ_succ_n : forall npp : Nat, n = succ (succ npp) -> Even npp -> Even n.
</syntaxhighlight>

つまり、上記の前者のように書くことを禁止し、後者のように書かなければならないと定めます。つまり、コンストラクタの返り値は定義する型と全く同じ形でなければなりません。

これによるメリットは <code>match</code> 式の <code>in</code> 節が不要になることや、 <code>match</code> 式の形式的な扱いがシンプルになることや、帰納型の定義の形式的な取り扱いが簡単になることや、 <code>inversion</code> タクティックに類するテクニックが不要になることなどがあります。デメリットは、定義が冗長になることなどがあります。

では、表現力はどうでしょうか。このような限定を行ったことで表現力が落ちる可能性もあります。

<syntaxhighlight lang="coq">
Inductive JMeq (A : Type) (x : A) : forall B : Type, B -> Type :=
  | jMeq_refl : Path A x A x.
</syntaxhighlight>

上記のような John Major's Equality を表現する型が、表せなくなる可能性がある型として挙げられるでしょう。

<syntaxhighlight lang="coq">
Inductive JMeq (A : Type) (x : A) (B : Type) (y : B) : Type :=
  | jMeq_refl : forall p : A = B, x = cast p y -> Path A x B y.
</syntaxhighlight>

しかし、上記のような <code>cast : A = B -> A -> B</code> という簡単に定義できる関数を使って、等価な型を定義することが出来ます。他の型でも同様にして解決できるはずです。
