Intheo というプログラミング言語を自作しています。自作プログラミング言語が茨の道であることはよく知られている通りですが、それでも自作しようと思った理由は、 Coq での余帰納型の扱いが悪すぎるということに尽きます。そこで、余帰納型の扱いが良い言語を作るついでに、色々なアイデアを詰め込んでみようというのが始まりです。

== Coq での余帰納型 ==

余帰納型は、英語では coinductive type と言います。 Haskell では余帰納型という言葉は意味を持ちません。 Coq や Agda のような停止性が保証されていなければならない言語において、その意味を持ち始めます。その名前の通り余帰納法に関係していますが、私の印象としては余帰納法を理解しなくても余帰納型を理解することが出来ます。

Coq における余帰納型についての信頼できる文献としては [https://coq.inria.fr/refman/language/core/coinductive.html Co-inductive types and co-recursive functions — Coq 8.12.2 documentation] ([https://web.archive.org/web/20201104192956/https://coq.inria.fr/refman/language/core/coinductive.html archive]) と [http://adam.chlipala.net/cpdt/html/Coinductive.html Coinductive — 
Certified Programming with Dependent Types] ([https://web.archive.org/web/20200216183013/http://adam.chlipala.net/cpdt/html/Coinductive.html archive]) があります。両方とも英語で書かれており、日本語で解説したほうが読者には親切なのでしょうが、この記事の主題から外れますので、機会があったら別の記事として書きたいと思います。

```coq
CoInductive CoNat : Type := coZero : CoNat | coSucc : CoNat -> CoNat.
```

余帰納型の定義の例を上記で示しました。この時点で、既に大きな問題があることが分かります。それは定義が「和」ベースになっていることです。どういうことかというと、帰納型はよく知られているようにコンストラクタが複数個あり直和型に似たものを作るのですが、余帰納型は直積型に似たものであるべきなのです。

{|
|-
| 帰納型 (inductive type)
| 余帰納型 (coinductive type)
|-
| 構築子 (constructor)
| 分解子 (destructor)
|-
| 帰納法の原理 (principle of induction)
| 余帰納法の原理 (principle of coinduction)
|-
| 直和型 (sum type)
| 直積型 (product type)
|}

美しくも圏論において帰納型と余帰納型は双対になりますが、その対応関係は上記のようになります。このことから分かるように余帰納型は分解子から構成されるべきなのですが、 Coq ではそうなっていません。

```coq
CoInductive Stream (A : Type) : Type :=
  & head : Stream A -> A
  & tail : Stream A -> Stream A.
```

上記のように書かれるべきなのではないでしょうか？ Intheo はこのような構文を持つ言語が欲しくて制作し始めたものです。
