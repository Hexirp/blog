Intheo というプログラミング言語を自作しています。自作プログラミング言語が茨の道であることはよく知られている通りですが、それでも自作しようと思った理由は、 Coq での余帰納型の扱いが悪すぎるということに尽きます。そこで、余帰納型の扱いが良い言語を作るついでに、色々なアイデアを詰め込んでみようというのが始まりです。

== 余帰納型 ==

余帰納型は、英語では coinductive type と言います。 Haskell では余帰納型という言葉は意味を持ちません。 Coq や Agda のような停止性が保証されていなければならない言語において、その意味を持ち始めます。その名前の通り余帰納法に関係していますが、私の印象としては余帰納法を理解しなくても余帰納型を理解することが出来ます。

Coq における余帰納型についての信頼できる文献としては [https://coq.inria.fr/refman/language/core/coinductive.html Co-inductive types and co-recursive functions — Coq 8.12.2 documentation] ([https://web.archive.org/web/20201104192956/https://coq.inria.fr/refman/language/core/coinductive.html archive]) と [http://adam.chlipala.net/cpdt/html/Coinductive.html Chapter 5 Infinite Data and Proofs — Certified Programming with Dependent Types] ([https://web.archive.org/web/20200216183013/http://adam.chlipala.net/cpdt/html/Coinductive.html archive]) があります。両方とも英語で書かれており、日本語で解説したほうが読者には親切なのでしょうが、この記事の主題から外れますので、機会があったら別の記事として書きたいと思います。

<syntaxhighlight lang="coq">
CoInductive CoNat : Type := coZero : CoNat | coSucc : CoNat -> CoNat.
</syntaxhighlight>

余帰納型の定義の例を上記で示しました。この時点で、既に大きな問題があることが分かります。それは定義が「和」ベースになっていることです。どういうことかというと、帰納型はよく知られているようにコンストラクタにより直和型に似たものを作るのですが、余帰納型は直積型に似たものであるべきなのです。

{|
|-
| 帰納型 (inductive type)
| 余帰納型 (coinductive type)
|-
| 構築子 (constructor)
| 分解子 (destructor)
|-
| 場合分け (pattern matching)
| 余場合分け (copattern matching)
|-
| 帰納法の原理 (principle of induction)
| 余帰納法の原理 (principle of coinduction)
|-
| 直和型 (sum type)
| 直積型 (product type)
|}

美しくも圏論において帰納型と余帰納型は双対になりますが、その対応関係は上記のようになります。このことから分かるように余帰納型は分解子から構成されるべきなのですが、 Coq ではそうなっていません。

<syntaxhighlight lang="coq">
CoInductive Stream (A : Type) : Type :=
  & head : Stream A -> A
  & tail : Stream A -> Stream A.
</syntaxhighlight>

上記のように書かれるべきなのではないでしょうか？ Intheo はこのような構文を持つ言語が欲しくて制作し始めたものです。

== 余場合分け ==

当然のことながら、分解子だけでは余帰納型を扱うことは出来ません。項の組み立ての方法が必要になります。これには前記の表に乗せた余場合分けが必要になります。

<syntaxhighlight lang="coq">
comatch
  & head := 0
  & tail := mapStream (plus 1) natStream
end
</syntaxhighlight>

仮想的に構文を設定すると上記のようになるでしょう。ただし、レコードの生成と同一の構文になるなどの選択の余地はあります。

== バリアント型 ==

型の定義において、帰納型と余帰納型は、定義にその型自身が現れるのを許容します。これを「再帰的な型の定義」と呼びます。一方で、定義に自分自身が現れない型もあり、これらは特別な扱いを受けるべきです。

{|
!
! 帰納的
! 余帰納的
|-
! 非再帰的
| バリアント型 (variant type)
| 余バリアント型 (covariant type)
|-
! 再帰的
| 帰納型 (inductive type)
| 余帰納型 (coinductive type)
|}

上記のように型の定義を分類すべきだと考えます。これを組み入れた言語を作るのも面白いでしょう。
