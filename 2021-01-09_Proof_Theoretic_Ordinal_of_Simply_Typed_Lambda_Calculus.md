# 単純型付きラムダ計算の証明論的順序数

単純型付きラムダ計算の証明論的順序数がいくつになるのか気になったので少し考えてみる。

## 2021-01-09

等号付き一階述語論理に `zero` と `succ` の関数記号を加えただけの理論を考える。それの証明論的順序数はいくつであろうか？

そもそも順序の定義をエンコードできないため、証明論的順序数は定義できない。具体的に言えば、理論の中に `P(x,y) ⇔ x < y` なる式が存在する必要がある。これはチューリングマシンなどを使って表現されるが、最初に挙げた論理ではチューリングマシンを扱えないため、証明論的順序数は定義できない。

同じように、 `nat` と `zero` と `succ` と `nat_ind` を含む単純型付きラムダ計算の証明論的順序数を考えようとしても、等式型や存在型がないため、証明論的順序数を考えることはできない。

## 2021-01-10

詳しく見ていくと、 strong normalization を示すのに障害になるのは application だけだということがわかる。

`Γ |- x : T` という judgement に順序を入れる。それを利用して strong normalization が示せたとする。そのような順序の中の最小であるものを利用して証明論的順序数を代替することは出来るだろうか。

`Γ |- x : T ⇓ y : T'` を `x` は `y` に簡約されるという述語とする。 strong normalization というのは、要するに、この逆関係が整礎であることである。

これを示すために、 `Γ |- x : T ⇓ y : T' → R y x` という写像を使って、何らかの整礎である順序 `R` から引き戻す。つまり、整礎であり `Γ |- x : T ⇓ y : T' → R y x` であるというのが求められている順序の条件である。

この順序の順序型の内で最小であるのが、ラムダ計算の体系に対する証明論的順序数であるとする。

これは……

整礎であり、簡約は一ステップずつしか行われないので、結局は ω になってしまう。もしかして、これがいわゆる Kruskal の反例なのか？ 絶対に違うだろうけど。

これを回避するためには、 `f : A -> B` の大きさは、少なくとも全ての `x : A` に対して `R (f x) f` であるような大きさであると定めたりと、色々と条件を付けるしかないのかな？

## 2020-01-12

そうすると、 `zero < succ zero < succ (succ zero) < ⋯ < succ` という風に順序が構成される。

`match n with zero => x | succ np => y end` というようなパターンマッチングなどにも順序に関する条件を考えられる。このように、条件を適切に定めていけば、証明論的順序数っぽいものが出来るのではないか。
