# Traversal 型クラスの二通りの形式化

## Traversal とは？

## 形式化とは？

Haskell は、圏論という理論の成果を積極的に利用しようとしてきました。恐らく、入出力にモナドを使うことにした時から始まった文化ですが、今や、これ自体が Haskell という言語の特徴の一つとして数えられるまでになっています。

Haskell の `Functor` 型クラスは、圏論の関手という概念で形式化できます。 Haskell の `Monad` 型クラスは、圏論のモナドという概念で形式化できます。しかし、無から関手だとかそういうものが出てくるわけではありません。関手には、構造を移す元の圏と構造を写す先の圏が必要です。 Haskell の `Functor` 型クラスは、 Hask 圏から Hask 圏への関手として形式化されます。そして、 Haskell の `Monad` 型クラスも、そういった形式化の上でモナドとして形式化されます。 `Traversable` 型クラスも同じように圏論を使って形式化できるのでしょうか。

ある概念を形式化したい時は、必ず足元からしっかりと定義を積み上げていく必要があります。当然、 Haskell の `Traversal` 型クラスを圏論で形式化する時も同じようにする必要があります。まず、全ての基本となる Hask 圏という概念を説明します。次に、 `Functor` 型クラスと `Applicative` 型クラスを関手により形式化します。最後に、 `Traversable` 型クラスを二通りの方法で形式化します。

## Hask 圏とは？

Hask 圏の対象は、 `Int`, `Maybe Int`, `[Bool]`, ... のような Haskell の型です。 `Maybe` などは Hask 圏の対象ではありません。

Hask 圏の射は、 Haskell の関数です。具体的に、対象 `a` から対象の `b` への射は、 `a -> b` という型の関数です。たとえば、 `not : Bool -> Bool` は `Bool` から `Bool` への射です。

`Int -> Bool` という**型**は Hask 圏の対象です。 `isEven :: Int -> Bool` という**関数**は対象 `Int` から対象 `Bool` への射です。 `(==) :: Int -> (Int -> Bool)` という**関数**は対象 `Int` から対象 `Int -> Bool` への射です。

## Applicative の形式的な定義をする。

## 1 番目の方法: Traversal を特別な自然変換を持つ関手として形式化する。

## 2 番目の方法: Traversal を特別な圏の自己関手として形式化する。
