# Traversal 型クラスの二通りの形式化

## Traversal 型クラスとは？

私は、 Haskell の `Traversable` という型クラスが好きです。

何らかを走査するのはプログラミングにおいて頻出するパターンです。他の言語ではイテレーターという概念を使って抽象化しますが、 Haskell では `Foldable` 型クラスを使って抽象化することが一般的です。

`Foldable` 型クラスは、ある一つの型を取って型を返す関数 `f` に対して、その要素を走査する方法を定めるものです。たとえば、 `f a = [a]` となっている時は、リストの要素を走査する方法を定めることになります。そうすると、 `sum x = foldl' (+) 0 x` のようにリストの要素の総和を取る関数を作れるようになります。

では、「要素」とは何でしょうか？ そんなの簡単じゃんと思う人もいるかもしれません。しかし、そうではありません。 `data Foo a = Foo a a` と定義すると、 `Foo` に対する `Foldable` 型クラスのインスタンスは `fold (Foo x y) = x <> y` という風に定義できます。では、 `data Foo a = Foo { this_is_for_debugging_logs_and_should_never_be_used :: a, true_value :: a }` と定義されている時はどうでしょうか？ `fold (Foo x y) = x <> y` として定義してもいいものでしょうか？ それとも、 `fold (Foo _ x) = x` と定義するべきでしょうか？

実のところ、どちらが正しいかどうかは定まっていないのです。両方とも正しいという訳ではありません。どちらも正しくないかもしれないし、どれか一方だけが正しいのかもしれません。何も決まっていないのです。それは、 `Foldable` 型クラスに、そのインスタンスがどうあるべきかという明確なルールがないからです。つまり、 `Foldable` 則というべきものがないのです。

`Monad` 型クラスには、 `Monad` 則があります。あるインスタンスが与えられたとき、それが正しいのか正しくないのかをきちんと判断できます。 `Functor` 型クラスも `Applicative` 型クラスもそうです。

`Foldable` 型クラスに則 (laws) を定めようという議論はありました。しかし、そのいずれも行き詰りになり、 `Foldable` 型クラスは無法者 (lawless) であり続けています。もちろん、法 (laws) が必要ない時もあります。しかし、どんな型でも `fold _ = mempty` によって `Foldable` 型クラスのインスタンスに出来ると知れば、どうでしょうか。

`Traversable` 型クラスは、そうではありません。きちんとした則 (laws) があり、異常なインスタンスは有志警察に捕まります。だから、私は `Traversable` 型クラスが好きです。

今日は、そんな `Traversable` 型クラスを形式化するとどうなるかを考えてみます。

## 形式化とは？

Haskell は、圏論という理論の成果を積極的に利用しようとしてきました。恐らく、入出力にモナドを使うことにした時から始まった文化ですが、今や、これ自体が Haskell という言語の特徴の一つとして数えられるまでになっています。

Haskell の `Functor` 型クラスは、圏論の関手という概念で形式化できます。 Haskell の `Monad` 型クラスは、圏論のモナドという概念で形式化できます。しかし、無から関手だとかそういうものが出てくるわけではありません。関手には、構造を移す元の圏と構造を写す先の圏が必要です。 Haskell の `Functor` 型クラスは、 Hask 圏から Hask 圏への関手として形式化されます。そして、 Haskell の `Monad` 型クラスも、そういった形式化の上でモナドとして形式化されます。 `Traversable` 型クラスも同じように圏論を使って形式化できるのでしょうか。

ある概念を形式化したい時は、必ず足元からしっかりと定義を積み上げていく必要があります。当然、 Haskell の `Traversal` 型クラスを圏論で形式化する時も同じようにする必要があります。まず、全ての基本となる Hask 圏という概念を説明します。次に、 `Functor` 型クラスと `Applicative` 型クラスを関手により形式化します。最後に、 `Traversable` 型クラスを二通りの方法で形式化します。

## Hask 圏とは？

Hask 圏は、 Haskell の型と値を圏として形式化したものです。

Hask 圏の対象は、 `Int`, `Maybe Int`, `[Bool]`, ... のような Haskell の型です。 `Maybe` などは Hask 圏の対象ではありません。

Hask 圏の射は、 Haskell の関数です。具体的に、対象 `a` から対象の `b` への射は、 `a -> b` という型の関数です。たとえば、 `not :: Bool -> Bool` は `Bool` から `Bool` への射です。

`Int -> Bool` という**型**は Hask 圏の対象です。 `isEven :: Int -> Bool` という**関数**は対象 `Int` から対象 `Bool` への射です。 `(==) :: Int -> Int -> Bool` という**関数**は対象 `Int` から対象 `Int -> Bool` への射です。

圏は、対象と射があるだけじゃダメです。恒等射と射の合成がなければなりません。

それぞれの対象に対して、その恒等射が存在する必要があります。たとえば、対象 `Int` には `Int` での恒等射がある必要があります。それは、 `Int -> Int` という型の関数です。それは、 `f = \x -> x` という関数です。同じように、対象 `Bool` には `Bool` での恒等射がある必要があります。それは、 `Bool -> Bool` という型の関数です。 Haskell には多相という仕組みがあるので、 `f = \x -> x` と書くだけで、全ての対象 `t` に対する恒等射を与えることが出来ます。その型は `t -> t` です。  `t` は `Int` にも `Bool` にもなります。つまり、その型は `Int -> Int` にも `Bool -> Bool` にもなります。 Hask 圏の恒等射は `id` です。この `id` は、どんな対象 `t` についての恒等射にもなれるからです。

対象 `a` と `b` と `c` と、射 `f : a -> b` と `g : b -> c` を考えます。射の合成は `(f ; g) : a -> c` である。これが常に存在しなければなりません。 Hask 圏においては、関数合成 `g . f` で `(f ; g)` が表されます。

圏には、射の合成についての則があります。まず、恒等射が単位元であるというものです。対象 `a` と ` b` を取って、射 `f :: a -> b` を取ります。

Hask 圏は、 Haskell の複雑な内部構造を上手く要点だけ取り出して抽象化します。 Hask 圏は、実際の Haskell とは違います。しかし、余程のことがない限り、 Hask 圏の上だけ考えても上手く行きます。実際の Haskell では、 `undefined` 関数や `seq` 関数や `error` 関数や `unsafePerformIO` 関数などにおいて、 Hask 圏と違いが出てきます。この辺りの話題は深掘りしません。

もう一度だけ念を押しますが、 Hask 圏は、実際の Haskell とは違います。でも、 Haskell のことについて考える時に、 Hask 圏という概念は、とても役に立ちます。

## Functor 型クラスの形式的な定義をする。

## Applicative 型クラスの形式的な定義をする。

## 1 番目の方法: Traversal 型クラスを特別な自然変換を持つ関手として形式化する。

## 2 番目の方法: Traversal 型クラスを特別な圏の自己関手として形式化する。
