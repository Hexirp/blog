チューリングマシンは一次元のテープを持つ。これはチューリング完全性を失わない最小の次元であり、その点では妥当ではある。だが、チューリングマシンのモデルは計算可能性を念頭において設計されたものであるからにして、計算複雑性の観点では疑問がないわけでもないのだ。

> メモリのアクセスは、本来は O(√n) なんですよね。 n はメモリのサイズであるとして。
> — [Hexirp, 2021-10-22, Twitter](https://twitter.com/hexirp_prixeh/status/1451397834029219864)

かつて、こんなことを呟いた。

> "The Myth of RAM" というシリーズ記事がありまして、実際にランダムアクセスの時間を測ると O(√n) になり、また理想的なメモリでも物理学的な制約によって O(√n) が限界になると説明しています。
> https://ilikebigbits.com/2014_04_21_myth_of_ram_1.html
> — [Hexirp, 2021-10-22, Twitter](https://twitter.com/hexirp_prixeh/status/1451459195568472074)

かつて、こんなことを呟いた。

> この挙動をシミュレートするには、二次元空間のテープを持つチューリングマシンを使うことが出来る
> — [Hexirp, 2021-10-23, Twitter](https://twitter.com/hexirp_prixeh/status/1451793693107638275)

かつて、こんなことを呟いた。

今日は、これらについて考察してみようと思う。

## ランダムアクセスの計算量

ランダムアクセスの計算量は O(1) とされる。これに異議を唱えたのが "[The Myth of RAM](http://ilikebigbits.com/2014_04_21_myth_of_ram_1.html)" という記事である。ここでは結論だけを引用させていただく——ランダムアクセスの計算量は O(√n) である。

とあるメモリが存在すると考える。そのメモリの量を n とする。そのメモリへランダムアクセスした時の計算量は O(√n) となる。これ以上の性能でランダムアクセスすることは出来ない。そういうことなのだ。

ここでのメモリの量の単位はビットでもバイトでも良い。単位での違いは定数倍にしかならない。キャッシュを使えば性能は上がるかもしれないが、キャッシュは**非**ランダムアクセスを前提にしている。

どこから n の 1/2 乗という式は出てきたのか？ 記事では二つの根拠が説明されている。

一つ目は、単純な実験の結果である。 [emilk/ram_bench](https://github.com/emilk/ram_bench) のコードにより計測された結果は 1/2 乗で近似されるように見える。残念ながら、これは確実な証拠ではない。

二つ目は、物理学的な限界によるものである。まず、我々は三次元空間に生きている。よって、時間 t でアクセスできる空間は球状になり、その体積は t の 3 乗に比例する。では、この空間にどれだけの情報を詰め込めるだろうか？ その限界を物理学は与えている——ベッケンシュタイン境界である。これは球状の空間の中に存在できる情報の量の限界を与えている。その限界に達する唯一の物体はブラックホールであり、ブラックホールの情報量は半径の 2 乗に比例する。すなわち、時間 t でアクセス可能な空間の中に詰め込める情報量の限界は t の 2 乗に比例するのである。これを逆側に解いて、メモリの量が n であるとき、そのメモリにランダムアクセスする時に必要な時間は O(√n) を**下回ることは出来ない**という結果が得られる。

## チューリングマシンのメモリ

チューリングマシンは一次元のテープを持つ。では、このテープの上でランダムアクセスしようとしたら、どうなるだろうか？

テープの切れ端を考える。このテープの中心にはマシンが乗っていて、そこから両端まで n 個のメモリがある。すなわち、全体では 2 * n + 1 個のメモリを持っている。マシンの真下のメモリにアクセスするには 0 ステップで済む。その一つ隣のメモリにアクセスするには 2 ステップが必要である。さらに遠くのメモリにアクセスするには更に時間が掛かり……という風になっている。

| n |    memory |        total time |                random access time |
|--:|----------:|------------------:|----------------------------------:|
| 0 |         1 |                 0 |                       0.000000... |
| 1 |         3 |                 4 |                       1.333333... |
| 2 |         5 |                12 |                       2.400000... |
| 3 |         7 |                24 |                       3.428571... |
| 4 |         9 |                40 |                       4.444444... |
| 5 |        11 |                60 |                       5.454545... |
| 6 |        13 |                84 |                       6.461538... |
| n | 2 * n + 1 | 2 * n ^ 2 + 2 * n | (2 * n ^ 2 + 2 * n) / (2 * n + 1) |

まず、メモリの数は 2 * n + 1 である。次に、これらのメモリにランダムアクセスする際の平均時間計算量を求める。そのために、全てのメモリにアクセスした時の時間計算量を求めなければならない。これは 2 * n ^ 2 + 2 * n になり、これをメモリの数で割ればランダムアクセスに必要な時間計算量が得られる。それは (2 * n ^ 2 + 2 * n) / (2 * n + 1) になる。

まとめると、 2 * n + 1 個のメモリにランダムアクセスする際の平均時間計算量は (2 * n ^ 2 + 2 * n) / (2 * n + 1) になるということである。つまり、チューリングマシンにおいて、メモリの量を m とすると、それらにランダムアクセスする際の平均時間計算量は O(m) となる。これは、明らかに現実でのランダムアクセスの性能よりも悪い。

よって、チューリングマシンは O(√n) のランダムアクセスをモデル化するためには不適当と分かる。

では、どのようなモデルであれば O(√n) のランダムアクセスを再現できるだろうか？

たとえば、 Word RAM というモデルがある。このモデルは基数ソートなどのワード数が効いてくるアルゴリズムのモデル化に使われるものであり、私が知る計算モデルの中では計算量の挙動が最も現実に近いものである。しかし、このモデルでもランダムアクセスが O(1) に設定されている。ランダムアクセスの計算量を直接的に O(2^(w/2)) と設定する方法もあるが、アドホックすぎる感も否めない。また、 Word RAM には、「加算や乗算を O(1) としてもよいのか」や「加算や乗算などを最初から組み込むのはシンプルではない」や「チューリングマシンのように計算途中で必要となればメモリを無限に継ぎ足せるようにしたい」などの思いもある。

## 二次元チューリングマシン

そこで登場するのが二次元チューリングマシンなのだ。

チューリングマシンのテープを二次元にしたものを考えよう。一次元の時と同じ議論でランダムアクセスの計算量を考察する。

| n |                memory |                                total time |                                                    random access time |
|--:|----------------------:|------------------------------------------:|----------------------------------------------------------------------:|
| 0 |                     1 |                                         0 |                                                           0.000000... |
| 1 |                     5 |                                         8 |                                                           1.600000... |
| 2 |                    13 |                                        40 |                                                           3.076923... |
| 3 |                    25 |                                       112 |                                                           4.480000... |
| 4 |                    41 |                                       240 |                                                           5.853658... |
| 5 |                    61 |                                       440 |                                                           7.213114... |
| 6 |                    85 |                                       728 |                                                           8.564705... |
| n | 2 * n ^ 2 + 2 * n + 1 | (8 / 3) * n ^ 3 + 4 * n ^ 2 + (4 / 3) * n | ((8 / 3) * n ^ 3 + 4 * n ^ 2 + (4 / 3) * n) / (2 * n ^ 2 + 2 * n + 1) |

まず、メモリの数は 2 * n ^ 2 + 2 * n + 1 である。次に、これらのメモリにランダムアクセスする際の平均時間計算量を求める。そのために、全てのメモリにアクセスした時の時間計算量を求めなければならない。これは (8 / 3) * n ^ 3 + 4 * n ^ 2 + (4 / 3) * n になり、これをメモリの数で割ればランダムアクセスに必要な時間計算量が得られる。それは ((8 / 3) * n ^ 3 + 4 * n ^ 2 + (4 / 3) * n) / (2 * n ^ 2 + 2 * n + 1) になる。

まとめると、 2 * n ^ 2 + 2 * n + 1 個のメモリにランダムアクセスする際の平均時間計算量は ((8 / 3) * n ^ 3 + 4 * n ^ 2 + (4 / 3) * n) / (2 * n ^ 2 + 2 * n + 1) になるということである。つまり、チューリングマシンにおいて、メモリの量を m とすると、それらにランダムアクセスする際の平均時間計算量は O(√m) となる。これはまさに現実のランダムアクセスの計算量に一致する。

すなわち、二次元チューリングマシンは現実的なランダムアクセスの計算量をモデル化するにあたって有効であるのだ。

## 余談・シーケンシャルアクセス

n 個のメモリの内の k 個にシーケンシャルアクセスする場合の時間計算量は O(√n+k) だと思われる。しかし、投機実行（アウトオブオーダー実行とか並列処理とかだったかも）を行う場合は効率が O(k√n) までに悪化してしまうという英語の論文を紹介する呟きを見かけた記憶がある。これの詳細を知っている人がいたら issue で教えてくれれば嬉しい。

## 余談・二次元の威力

二次元チューリングマシンのことを調べていたら、 "[Universality in Two Dimensions](http://www.cs.tau.ac.il/~nachumd/papers/2D.pdf)" という論文を見つけた。これが凄い。

チューリングマシンよりも更に単純な仕組みでありながら、加算から万能機械に至るまで容易に構築できてしまう。具体的な仕組みは Brainf\*ck の二次元版のことを思い浮かべて貰えば分かりやすいかもしれない。しかし、 Brainf\*ck とは違って 8 ビットのメモリという恣意性はないのだ。たった十数個のシンボルだけを使う。
